{
  "version": 3,
  "sources": ["../../dlv/index.js", "../../@analytics/type-utils/src/index.js", "../../analytics-utils/src/decodeUri.js", "../../analytics-utils/src/getBrowserLocale.js", "../../analytics-utils/src/getTimeZone.js", "../../analytics-utils/src/isExternalReferrer.js", "../../analytics-utils/src/isScriptLoaded.js", "../../analytics-utils/src/paramsClean.js", "../../analytics-utils/src/paramsGet.js", "../../analytics-utils/src/paramsParse.js", "../../analytics-utils/src/paramsRemove.js", "../../analytics-utils/src/url.js", "../../analytics-utils/src/parseReferrer.js", "../../analytics-utils/src/uuid.js", "../../analytics-utils/src/throttle.js", "../../@analytics/global-storage-utils/src/index.js", "../../@analytics/src/vendor/redux/utils/defs.js", "../../@analytics/src/vendor/redux/createStore.js", "../../@analytics/src/vendor/redux/combineReducers.js", "../../@analytics/src/vendor/redux/compose.js", "../../@analytics/src/vendor/redux/applyMiddleware.js", "../../@analytics/src/constants.js", "../../@analytics/src/utils/internalConstants.js", "../../@analytics/src/events.js", "../../@analytics/src/middleware/initialize.js", "../../@analytics/src/modules/user.js", "../../@analytics/src/middleware/identify.js", "../../@analytics/src/utils/callback-stack.js", "../../@analytics/src/utils/waitForReady.js", "../../@analytics/src/utils/heartbeat.js", "../../@analytics/src/middleware/plugins/engine.js", "../../@analytics/src/middleware/plugins/index.js", "../../@analytics/src/utils/filterDisabled.js", "../../@analytics/src/middleware/storage.js", "../../@analytics/src/middleware/dynamic.js", "../../@analytics/src/modules/plugins.js", "../../@analytics/src/utils/serialize.js", "../../@analytics/src/modules/track.js", "../../@analytics/src/modules/queue.js", "../../@analytics/src/modules/page.js", "../../@analytics/src/modules/context.js", "../../@analytics/src/utils/getOSName/browser.js", "../../@analytics/src/utils/handleNetworkEvents.js", "../../@analytics/src/utils/debug.js", "../../@analytics/src/utils/ensureArray.js", "../../@analytics/src/utils/enrichMeta.js", "../../@analytics/src/utils/getCallback.js", "../../@analytics/src/utils/timestamp.js", "../../@analytics/src/index.js", "../../@analytics/cookie-utils/src/index.js", "../../@analytics/localstorage-utils/src/index.js", "../../@analytics/session-storage-utils/src/index.js", "../../@analytics/storage-utils/src/utils/parse.js", "../../@analytics/storage-utils/src/index.js", "../../analytics/lib/analytics.browser.es.js", "dep:analytics"],
  "sourcesContent": ["export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n", "\n/*\n  Constants for reuse\n*/\n\nexport const FUNCTION = 'function'\nexport const STRING = 'string'\nexport const UNDEFINED = 'undefined'\nexport const BOOLEAN = 'boolean'\nexport const OBJECT = 'object'\nexport const ARRAY = 'array'\nexport const NUMBER = 'number'\nexport const SYMBOL = 'symbol'\nexport const NULL = 'null'\nexport const ERROR = 'error'\nexport const TYPE_ERROR = 'typeError'\nexport const SYNTAX_ERROR = 'syntaxError'\nexport const ASYNC_FUNCTION = 'asyncFunction'\nexport const GENERATOR_FUNCTION = 'generatorFunction'\nexport const ASYNC_GENERATOR_FUNCTION = 'asyncGeneratorFunction'\n\nexport const noOp = () => {}\nexport const ANY = 'any'\nexport const ALL = '*'\nexport const NONE = 'none'\nexport const HIDDEN = 'hidden'\nexport const PREFIX = '__'\n\n/* DOM Constants */\nexport const FORM = 'form'\nexport const INPUT = 'input'\nexport const BUTTON = 'button'\nexport const SELECT = 'select'\nexport const CHANGE = 'change'\nexport const SUBMIT = 'submit'\n\n/* Regex patterns */\nexport const REGEX_ISO = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)$/\nexport const REGEX_EMAIL = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\nexport const REGEX_JSON = /^\\{[\\s\\S]*\\}$|^\\[[\\s\\S]*\\]$/\n\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnvironment checks\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n/** @type {Object} */\nconst PROCESS = typeof process !== UNDEFINED ? process : {}\n\n/** @type {String} */\nexport const ENV = (PROCESS.env && PROCESS.env.NODE_ENV) || ''\n\n/** @type {Boolean} */\nexport const isProd = ENV === 'production'\n\n/** @type {Boolean} */\nexport const isStaging = ENV === 'staging'\n\n/** @type {Boolean} */\nexport const isDev = ENV === 'development'\n\n/** @type {Boolean} */\nexport const isBrowser = typeof window !== UNDEFINED\n/** @type {Boolean} */\nexport const isLocalHost = isBrowser && window.location.hostname === 'localhost'\n\n/** @type {Boolean} */\nexport const isNode = PROCESS.versions != null && PROCESS.versions.node != null\n\n/** @type {Boolean} */\nexport const isDeno = typeof Deno !== UNDEFINED && typeof Deno.core !== UNDEFINED;\n\n/** @type {Boolean} */\nexport const isWebWorker = typeof self === OBJECT && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope'\n\n/** @type {Boolean} */\nexport const isJsDom = (isBrowser && window.name === 'nodejs') || (typeof navigator !== UNDEFINED && (navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom')))\n\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nType checks\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n\nfunction text(method, s) {\n  return s.charAt(0)[method]() + s.slice(1)\n}\n\nconst upper = text.bind(null, 'toUpperCase')\nconst lower = text.bind(null, 'toLowerCase')\n\n/**\n * Returns the object type of the given payload\n * @param {*} val\n * @returns {string}\n */\nexport function getTypeName(val) {\n  if (isNull(val)) return upper(NULL)\n  return (typeof val === OBJECT) ? ctorName(val) : Object.prototype.toString.call(val).slice(8, -1)\n}\n\n/**\n * Returns the object type of the given payload\n * @param {*} val\n * @returns {string}\n */\nexport function getType(val, toLowerCase = true) {\n  const type = getTypeName(val)\n  // console.log('type', type)\n  return (toLowerCase) ? lower(type) : type\n}\n\n// export function getType(val) {\n//   if (isNull(val)) return NULL\n//   const type = typeof val\n//   if (type === OBJECT) return ctorName(val).toLowerCase()\n//   return type\n// }\n\nfunction typeOf(kind, val) {\n  return typeof val === kind\n}\n\n/** \n * Check if value is function.\n * @param x\n * @return {x is Function}\n */\nexport const isFunction = typeOf.bind(null, FUNCTION)\n\n/** \n * Check if value is string.\n * @param x\n * @return {x is string}\n */\nexport const isString = typeOf.bind(null, STRING)\n\n/** \n * Check if value is undefined.\n * @param x\n * @return {x is undefined}\n */\nexport const isUndefined = typeOf.bind(null, UNDEFINED)\n\n/** \n * Check if value is not undefined.\n * @param x\n * @return {x is undefined}\n */\nexport function isDefined(x) {\n  return !isUndefined(x)\n}\n\n/** \n * @param x\n * @return {x is boolean}\n */\nexport const isBoolean = typeOf.bind(null, BOOLEAN)\n\n/** \n * @param x\n * @return {x is symobl}\n */\nexport const isSymbol = typeOf.bind(null, SYMBOL)\n\n/** \n * @param x\n * @return {x is boolean}\n * @example\n * isNull(null)\n * // true\n */\nexport function isNull(x) {\n  return x === null\n}\n\n/** \n * Check if value is number.\n * @param n\n * @return {boolean}\n * @example\n * > isNumber(0)\n * true\n * > isNumber(1)\n * true\n * > isNumber(1.1)\n * true\n * > isNumber(0xff)\n * true\n * > isNumber(0644)\n * true\n * > isNumber(6.2e5)\n * true\n * > isNumber(NaN)\n * false\n * > isNumber(Infinity)\n * true\n */\nexport function isNumber(n) {\n  return getType(n) === NUMBER && !isNaN(n)\n}\n\nexport function isNumberLike(n) {\n  return !isNaN(parseFloat(n))\n}\n\n/** \n * Check if value is ES2015 `class`.\n * @param x\n * @return {x is Class}\n */\nexport function isClass(x) {\n  if (isFunction(x)) {\n    return /^class /.test(Function.prototype.toString.call(x))\n  }\n  return false\n}\n\n/** \n * @template T\n * @param x\n * @return {x is Array<T>}\n */\nexport function isArray(x) {\n  return getType(x) === ARRAY\n}\n\n/** \n * @param obj\n * @return {obj is Object}\n */\nexport function isObject(obj) {\n  if (!isObjectLike(obj)) return false\n\n  let proto = obj\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto)\n  }\n\n  return Object.getPrototypeOf(obj) === proto\n}\n\nexport function isObjectLike(obj) {\n  return obj && (typeof obj === OBJECT || obj !== null)\n}\n\n/**\n* Tests if a value is a parseable JSON string.\n* @param {*} x - value to test\n* @returns {boolean} boolean indicating if a value is a parseable JSON string\n* @example\n* isJson('{\"a\":5}') // returns true\n* isJson('[]') // returns true\n* isJson('{a\":5}') // returns false\n*/\nexport function isJson(x) {\n  if (!isString(x) || !REGEX_JSON.test(x)) return false\n  try {\n    JSON.parse(x)\n  } catch (e) { \n    return false\n  }\n  return true\n}\n\n/**\n * Is primative scalar value\n * @param x\n * @return {boolean}\n * @example\n   isPrimitive(true) =>  true\n   isPrimitive({}) => false\n   isPrimitive(0) =>  true\n   isPrimitive('1') =>  true\n   isPrimitive(1.1) =>  true\n   isPrimitive(NaN) =>  true\n   isPrimitive(Infinity) =>  true\n   isPrimitive(function() {}) => false\n   isPrimitive(Date), => false\n   isPrimitive(null) =>  true\n   isPrimitive(undefined) =>  true\n */\nexport function isPrimitive(x) {\n  if (isNull(x)) return true\n  // if (isNaN(x)) return false\n  switch (typeof x) {\n    case STRING:\n    case NUMBER:\n    case SYMBOL:\n    case UNDEFINED:\n    case BOOLEAN:\n      return true\n    default:\n      return false\n  }\n}\n\n/**\n* Tests if an object has a specified method name.\n* @param {*} value - value to test\n* @param {*} property - property to test\n* @returns {boolean} boolean indicating if an object has a specified method name\n* @example\n* const obj = {\n*   key: myFunc,\n*   keyTwo: 'foobar'\n* }\n* isMethod(obj, 'key' ) // returns true\n* isMethod(obj, 'keyTwo' ) // returns false\n* isMethod(obj, 'otherThing' ) // returns false\n*/\nexport function isMethod(value, prop) {\n  return isObject(value) && isFunction(value[prop])\n}\n\n/**\n * Returns true if the input is a Promise.\n * @param {*} x - The input to test\n * @returns {boolean}\n */\nexport function isPromise(x) {\n  if (!x) return false\n  return !!(!isUndefined(Promise) && x instanceof Promise || x.then && isFunction(x.then))\n}\n\n/**\n * Returns true if the input is a generator.\n * @param {*} x - The input to test\n * @returns {boolean}\n */\nexport function isGenerator(x) {\n  return isObjectLike(x) && isFunction(x.throw) && isFunction(x.return) && isFunction(x.next)\n}\n\n/** \n * Is generator function\n * @param x\n * @return {boolean}\n * @example\n   isGeneratorFunction(() => {}) =>  false\n   isGeneratorFunction(function* () => {}) =>  true\n   isGeneratorFunction(function * () {\n     yield 'my-val'\n   }))\n */\nexport function isGeneratorFunction(x) {\n  return getType(x) === GENERATOR_FUNCTION\n}\n\n/** \n * Is async function\n * @param x\n * @return {boolean}\n * @example\n   isAsyncFunction(() => {}) =>  false\n   isAsyncFunction(async () => {}) =>  true\n */\nexport function isAsyncFunction(x) {\n  return getType(x) === ASYNC_FUNCTION\n}\n\n\nexport function ctorName(x) {\n  return isFunction(x.constructor) ? x.constructor.name : null\n}\n\n/**\n * Returns true if the input is a Set.\n * @param {*} x - The input to test\n * @returns {boolean}\n */\nexport function isSet(value) {\n  return value instanceof Set\n}\n\n/**\n * Returns true if the input is a Map.\n * @param {*} x - The input to test\n * @returns {boolean}\n */\nexport function isMap(value) {\n  return value instanceof Map\n}\n\n/**\n * Check if value is regexp\n * @param {*} value - Value to check\n * @return {boolean} \n */\nexport function isRegex(value) {\n  return value instanceof RegExp\n}\n\n/**\n * Check if value is Buffer\n * @param {*} value - Value to check\n * @return {boolean} \n */\nexport function isBuffer(val) {\n  if (val.constructor && isFunction(val.constructor.isBuffer)) {\n    return val.constructor.isBuffer(val)\n  }\n  return false\n}\n\n/**\n * Check if value is Error\n * @param x - Object to check\n * @return {Boolean} If value is error\n * @example\n * isError(new Error()) // True\n */\nexport function isError(x) {\n  return x instanceof Error || (isString(x.message) && x.constructor && isNumber(x.constructor.stackTraceLimit))\n}\n\n/**\n * Check if value error like (i.e has the name and message properties, both of which are strings)\n * @param obj - Object to check\n * @return {Boolean} If object is error-like\n * via https://github.com/Luke-zhang-04/utils/blob/master/src/typeGuards.ts#L62\n * @example\n *\n * ```js\n * isErrorLike(new Error()) // True\n * isErrorLike({name: \"Error!\", message: \"This is an error\", other: 0}) // True\n * isErrorLike({}) // False\n * isErrorLike({name: \"Error\", message: null}) // False\n *\n * // Works as a typguard\n * const something = {name: \"Error\", message: \"This is an error\"} as unknown\n *\n * if (isErrorLike(something)) {\n *   console.log(something.name) // No Typescript error\n * }\n * ```\n */\nexport function isErrorLike(obj) {\n  return isObjectLike(obj) && isString(obj.message) && isString(obj.name)\n}\n\nfunction errorType(ErrKind, value) {\n  if (typeof value !== 'object' || isNull(value)) return false\n  // Check for `TypeError` objects from the same realm (same Node.js `vm` or same `Window` object)...\n  if (value instanceof ErrKind) return true\n  const typeName = getType(new ErrKind(''))\n  // All `TypeError` objects are `Error` objects...\n  if (isError(value)) {\n    while (value) {\n      if (getType(value) === typeName) {\n        return true\n      }\n        value = Object.getPrototypeOf(value)\n    }\n  }\n  return false\n}\n\nexport const isTypeError = errorType.bind(null, TypeError)\n\nexport const isSyntaxError = errorType.bind(null, SyntaxError)\n\n/** \n * @param func - function to check if noOp\n * @return {Boolean} - is noOp\n * @examples\n   function foo() {}\n   isNoOp(foo) // true\n   isNoOp(() => { }) // true\n   isNoOp(() => { console.log('hi') }) // false\n */\nexport function isNoOp(func) {\n  if (!isFunction(func)) return false\n  const emptyFunc = /{(\\r|\\n|\\s)*}/gm\n  const noOpStr = noOp + ''\n  const funcString = (func.toString().match(emptyFunc) || [''])[0].replace(emptyFunc, noOpStr)\n  return noOpStr === funcString\n}\n\n/**\n * Check if value is function arguments\n * @param {*} val \n * @returns \n */\nexport function isArguments(val) {\n  try {\n    if (isNumber(val.length) && isFunction(val.callee)) return true\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) return true\n  }\n  return false\n}\n\n/**\n * Check if value is truthy\n * @param {*} value \n * @return {Boolean} - is truthy value\n */\nexport function isTruthy(v) {\n  if (isString(v) && v.toLowerCase() === 'false') return false\n  return !!v\n}\n\n/**\n * Check if value is falsy\n * @param {*} x \n * @return {Boolean} - is falsy value\n * @example\n * isFalsy(false) // returns true\n * isFalsy(null) // returns true\n * isFalsy('') // returns true\n * isFalsy(0) // returns true\n * isFalsy(void 0) // returns true\n * isFalsy(NaN) // returns true\n * isFalsy([]) // returns false\n */\nexport function isFalsy(x) {\n  return x ? false : true\n}\n\n// ^ future updates https://github.com/thenativeweb/boolean\n\n/**\n * Check if value is true\n * @param {*} x \n * @return {Boolean} - is true\n */\nexport function isTrue(x) {\n  return x === true\n}\n\n/**\n * Check if value is true\n * @param {*} x \n * @return {Boolean} - is true\n */\nexport function isFalse(x) {\n  return x === false\n}\n\n/**\n * Check if value is email\n * @param {*} x \n * @return {Boolean} - is email like value\n */\nexport function isEmail(x) {\n  if (x.length > 320) return false\n  return REGEX_EMAIL.test(x)\n}\n\n/**\n * Check if valie is date\n * @param {*} val \n * @returns {Boolean}\n */\nexport function isDate(x) {\n  if (x instanceof Date) return true\n  return isFunction(x.toDateString) && isFunction(x.getDate) && isFunction(x.setDate)\n}\n\n/**\n * Check if value is ISO date e.g. '2022-01-02T06:45:28.547Z'\n * @param {*} x\n * @return {Boolean} - is email like value\n */\nexport function isIsoDate(x) {\n  return REGEX_ISO.test(x)\n}\n\n/**\n * Is value empty\n * @param {*} x \n * @returns {Boolean}\n * @example\n * isEmpty(null)\n *\n * isEmpty([1, 2, 3])\n * // => false\n *\n * isEmpty('abc')\n * // => false\n *\n * isEmpty({ 'a': 1 })\n * // => false\n */\nexport function isEmpty(x) {\n  if (isNull(x)) return true\n  if (isArray(x)) return !x.length\n  if (isSet(x) || isMap(x)) return !x.size\n  if (isObject(x)) return !Object.keys(x).length\n  return true\n}\n\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nHTML Element checks\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n\n/** \n * @param obj\n * @return {obj is NodeList}\n */\nexport function isNodeList(obj) {\n  return NodeList.prototype.isPrototypeOf(obj)\n}\n\n/**\n * Check if input is DOM element\n * @param {HTMLElement|*} element\n * @return {boolean} \n */\nexport function isElement(element, type) {\n  const isEl = element instanceof Element || element instanceof HTMLDocument\n  if (!isEl || !type) return isEl\n  return isNodeType(element, type)\n}\n\n/**\n * Check if element is specific DOMNode type\n * @param {HTMLElement|*} element\n * @param {String} type\n * @return {boolean}\n */\nexport function isNodeType(element, type = '') {\n  return element && element.nodeName === type.toUpperCase()\n}\n\nfunction bindArgs(fn, ...boundArgs) {\n  return function(...args) {\n    return fn(...args, ...boundArgs)\n  }\n}\n\n/**\n * Check if element is form element\n * @param {HTMLElement} element\n * @return {boolean} \n */\nexport const isForm = bindArgs(isElement, FORM)\n\n/**\n * Check if element is button element\n * @param {HTMLElement} element\n * @return {boolean} \n */\nexport const isButton = bindArgs(isElement, BUTTON)\n\n/**\n * Check if element is input element\n * @param {HTMLElement} element\n * @return {boolean} \n */\nexport const isInput = bindArgs(isElement, INPUT)\n\n/**\n * Check if element is select element\n * @param {HTMLElement} element\n * @return {boolean} \n */\nexport const isSelect = bindArgs(isElement, SELECT)\n\n/**\n * Check if DOM element is hidden\n * @param {HTMLElement|null|undefined} element\n * @param {HTMLElement|null|undefined} until\n * @return {boolean}\n */\nexport function isHidden(element, until) {\n  if (!element || getComputedStyle(element).visibility === HIDDEN) return true\n\n  while (element) {\n    if (until != null && element === until) return false\n    if (getComputedStyle(element).display === NONE) return true\n    element = element.parentElement\n  }\n\n  return false\n}\n\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nEnsure Values\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n\n/**\n * Ensure value returned is Array\n * @param {*} singleOrArray \n * @returns [*]\n */\nexport function ensureArray(singleOrArray) {\n  if (!singleOrArray) return []\n  if (isArray(singleOrArray)) return singleOrArray\n  return [singleOrArray]\n}", "/**\n * Decode URI string\n *\n * @param {String} s string to decode\n * @returns {String} decoded string\n * @example\n * decode(\"Bought%20keyword)\n * => \"Bought keyword\"\n */\nexport function decodeUri(s) {\n  try {\n    return decodeURIComponent(s.replace(/\\+/g, ' '))\n  } catch (e) {\n    return null\n  }\n}\n", "import { isBrowser } from '@analytics/type-utils'\n\n/**\n * @returns {string | undefined}\n */\nexport function getBrowserLocale() {\n  if (!isBrowser) return\n  const { language, languages, userLanguage } = navigator\n  if (userLanguage) return userLanguage // IE only\n  return (languages && languages.length) ? languages[0] : language\n}\n", "\n/**\n * @returns {string | undefined}\n */\nexport function getTimeZone() {\n  try {\n    return Intl.DateTimeFormat().resolvedOptions().timeZone\n  } catch (error) {}\n}\n", "import { isBrowser } from '@analytics/type-utils'\n\n/**\n * @param {string | null | undefined} ref\n * @returns {boolean | undefined}\n */\nexport function isExternalReferrer(ref) {\n  if (!isBrowser) return false\n  const referrer = ref || document.referrer\n  if (referrer) {\n    const port = window.document.location.port\n    let ref = referrer.split('/')[2]\n    if (port) {\n      ref = ref.replace(`:${port}`, '')\n    }\n    return ref !== window.location.hostname\n  }\n  return false\n}\n", "import { isBrowser, isString, isRegex } from '@analytics/type-utils'\n\n/**\n * Check if a script is loaded\n * @param  {String|RegExp} script - Script src as string or regex\n * @return {Boolean} is script loaded\n */\nexport function isScriptLoaded(script) {\n  if (!isBrowser) return true\n  const scripts = document.getElementsByTagName('script')\n  return !!Object.keys(scripts).filter((key) => {\n    const { src } = scripts[key]\n    if (isString(script)) {\n      return src.indexOf(script) !== -1\n    } else if (isRegex(script)) {\n      return src.match(script)\n    }\n    return false\n  }).length\n}\n", "\n/**\n * Strip a query parameter from a url string\n * @param  {string} url   - url with query parameters\n * @param  {string} param - parameter to strip\n * @return {string} cleaned url\n */\nexport function paramsClean(url, param) {\n  const search = (url.split('?') || [ , ])[1] // eslint-disable-line\n  if (!search || search.indexOf(param) === -1) {\n    return url\n  }\n  // remove all utm params from URL search\n  const regex = new RegExp(`(\\\\&|\\\\?)${param}([_A-Za-z0-9\"+=.\\\\/\\\\-@%]+)`, 'g')\n  const cleanSearch = `?${search}`.replace(regex, '').replace(/^&/, '?')\n  // replace search params with clean params\n  const cleanURL = url.replace(`?${search}`, cleanSearch)\n  // use browser history API to clean the params\n  return cleanURL\n}\n", "import {decodeUri} from './decodeUri'\n\n/**\n * Get a given query parameter value\n * @param  {string} param - Key of parameter to find\n * @param  {string} url - url to search\n * @return {string} match\n */\nexport function paramsGet(param, url) {\n  return decodeUri((RegExp(`${param}=(.+?)(&|$)`).exec(url) || [, ''])[1])\n}\n", "import { isBrowser } from '@analytics/type-utils'\nimport { decodeUri } from './decodeUri'\n\n/**\n * Get search string from given url\n * @param  {string} [url] - optional url string. If no url, window.location.search will be used\n * @return {string} url search string\n */\nfunction getSearchString(url) {\n  if (url) {\n    const p = url.match(/\\?(.*)/)\n    return (p && p[1]) ? p[1].split('#')[0] : ''\n  }\n  return isBrowser && window.location.search.substring(1)\n}\n\n/**\n * Parse url parameters into javascript object\n * @param  {string} [url] - URI to parse. If no url supplied window.location will be used\n * @return {object} parsed url parameters\n */\nexport function paramsParse(url) {\n  return getParamsAsObject(getSearchString(url))\n}\n\n/*\n?first=abc&a[]=123&a[]=false&b[]=str&c[]=3.5&a[]=last\nhttps://random.url.com?Target=Report&Method=getStats&fields%5B%5D=Offer.name&fields%5B%5D=Advertiser.company&fields%5B%5D=Stat.clicks&fields%5B%5D=Stat.conversions&fields%5B%5D=Stat.cpa&fields%5B%5D=Stat.payout&fields%5B%5D=Stat.date&fields%5B%5D=Stat.offer_id&fields%5B%5D=Affiliate.company&groups%5B%5D=Stat.offer_id&groups%5B%5D=Stat.date&filters%5BStat.affiliate_id%5D%5Bconditional%5D=EQUAL_TO&filters%5BStat.affiliate_id%5D%5Bvalues%5D=1831&limit=9999\nhttps://random.url.com?Target=Offer&Method=findAll&filters%5Bhas_goals_enabled%5D%5BTRUE%5D=1&filters%5Bstatus%5D=active&fields%5B%5D=id&fields%5B%5D=name&fields%5B%5D=default_goal_name\nhttp://localhost:3000/?Target=Offer&Method=findAll&filters[has_goals_enabled][TRUE]=1&filters[status]=active&filters[wow]arr[]=yaz&filters[wow]arr[]=naz&fields[]=id&fields[]=name&fields[]=default_goal_name */\n\n\n\nfunction getParamsAsObject(query) {\n  let params = Object.create(null)\n  let temp\n  const re = /([^&=]+)=?([^&]*)/g\n\n  while (temp = re.exec(query)) {\n    var k = decodeUri(temp[1])\n    var v = decodeUri(temp[2])\n    if (k.substring(k.length - 2) === '[]') {\n      k = k.substring(0, k.length - 2);\n      (params[k] || (params[k] = [])).push(v)\n    } else {\n      params[k] = (v === '') ? true : v\n    }\n  }\n\n  for (var prop in params) {\n    var arr = prop.split('[')\n    if (arr.length > 1) {\n      assign(params, arr.map((x) => x.replace(/[?[\\]\\\\ ]/g, '')), params[prop])\n      delete params[prop]\n    }\n  }\n  return params\n}\n\nfunction assign(obj, keyPath, value) {\n  var lastKeyIndex = keyPath.length - 1\n  for (var i = 0; i < lastKeyIndex; ++i) {\n    var key = keyPath[i]\n    if (key === '__proto__' || key === 'constructor') {\n      break;\n    }\n    if (!(key in obj)) { \n      obj[key] = {} \n    }\n    obj = obj[key]\n  }\n  obj[keyPath[lastKeyIndex]] = value\n}\n\n\n/*\nhttps://github.com/choojs/nanoquery/blob/791cbdfe49cc380f0b2f93477572128946171b46/browser.js\nvar reg = /([^?=&]+)(=([^&]*))?/g\n\nfunction qs (url) {\n  var obj = {}\n  url.replace(/^.*\\?/, '').replace(reg, function (a0, a1, a2, a3) {\n    var value = decodeURIComponent(a3)\n    var key = decodeURIComponent(a1)\n    if (obj.hasOwnProperty(key)) {\n      if (Array.isArray(obj[key])) obj[key].push(value)\n      else obj[key] = [obj[key], value]\n    } else {\n      obj[key] = value\n    }\n  })\n  return obj\n}\n*/", "import { isBrowser } from '@analytics/type-utils'\nimport { paramsClean } from './paramsClean'\n\n/**\n * Removes params from url in browser\n * @param  {string}   param       - param key to remove from current URL\n * @param  {() => void} [callback]  - callback function to run. Only runs in browser\n * @return {PromiseLike<void>}\n */\nexport function paramsRemove(param, callback) {\n  if (!isBrowser) return Promise.resolve()\n\n  return new Promise((resolve, reject) => {\n    if (window.history && window.history.replaceState) {\n      const url = window.location.href\n      const cleanUrl = paramsClean(url, param)\n      if (url !== cleanUrl) {\n        /* replace URL with history API */\n        // eslint-disable-next-line no-restricted-globals\n        history.replaceState({}, '', cleanUrl)\n      }\n    }\n\n    if (callback) callback()\n\n    return resolve()\n  })\n}\n", "import { isBrowser } from '@analytics/type-utils'\n\n/**\n * Get host domain of url\n * @param  {String} url - href of page\n * @return {String} hostname of page\n *\n * @example\n *  getDomainHost('https://subdomain.my-site.com/')\n *  > subdomain.my-site.com\n */\nexport function getDomainHost(url) {\n  if (!isBrowser) return null\n  const a = document.createElement('a')\n  a.setAttribute('href', url)\n  return a.hostname\n}\n\n/**\n * Get host domain of url\n * @param  {String} url - href of page\n * @return {String} base hostname of page\n *\n * @example\n *  getDomainBase('https://subdomain.my-site.com/')\n *  > my-site.com\n */\nexport function getDomainBase(url) {\n  const host = getDomainHost(url) || ''\n  return host.split('.').slice(-2).join('.')\n}\n\n/**\n * Remove TLD from domain string\n * @param  {String} baseDomain - host name of site\n * @return {String}\n * @example\n *  trimTld('google.com')\n *  > google\n */\nexport function trimTld(baseDomain) {\n  const arr = baseDomain.split('.')\n  return (arr.length > 1) ? arr.slice(0, -1).join('.') : baseDomain\n}\n\nexport default {\n  trimTld,\n  getDomainBase,\n  getDomainHost\n}\n", "import { isBrowser } from '@analytics/type-utils'\nimport { paramsParse } from './paramsParse'\nimport { isExternalReferrer } from './isExternalReferrer'\nimport { trimTld, getDomainBase } from './url'\n\nconst googleKey = 'google'\n\n/**\n * @typedef {{\n *  campaign: string,\n *  referrer?: string,\n * } & DomainObject & Object.<string, any>} ReferrerObject\n */\n\n/**\n * Checks a given url and parses referrer data\n * @param  {String} [referrer] - (optional) referring URL\n * @param  {String} [currentUrl] - (optional) the current url\n * @return {ReferrerObject}     [description]\n */\nexport function parseReferrer(referrer, currentUrl) {\n  if (!isBrowser) return false\n  // default referral data\n  let refData = {\n    'source': '(direct)',\n    'medium': '(none)',\n    'campaign': '(not set)'\n  }\n  // Add raw ref url if external\n  if (referrer && isExternalReferrer(referrer)) {\n    refData.referrer = referrer\n  }\n\n  const domainInfo = parseDomain(referrer)\n  // Read referrer URI and infer source\n  if (domainInfo && Object.keys(domainInfo).length) {\n    refData = Object.assign({}, refData, domainInfo)\n  }\n\n  // Read URI params and use set utm params\n  const params = paramsParse(currentUrl)\n  const paramKeys = Object.keys(params)\n  if (!paramKeys.length) {\n    return refData\n  }\n\n  // set campaign params off GA matches\n  const gaParams = paramKeys.reduce((acc, key) => {\n    // match utm params & dclid (display) & gclid (cpc)\n    if (key.match(/^utm_/)) {\n      acc[`${key.replace(/^utm_/, '')}`] = params[key]\n    }\n    // https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters\n    // dclid - cpc Cost-Per-Thousand Impressions\n    // gclid - cpc Cost per Click\n    if (key.match(/^(d|g)clid/)) {\n      acc['source'] = googleKey\n      acc['medium'] = (params.gclid) ? 'cpc' : 'cpm'\n      acc[key] = params[key]\n    }\n    return acc\n  }, {})\n\n  return Object.assign({}, refData, gaParams)\n}\n\n/**\n * @typedef {{\n *  source: string,\n *  medium: string,\n *  term?: string\n * }} DomainObject\n */\n\n/**\n * Client side domain parser for determining marketing data.\n * @param  {String} referrer - ref url\n * @return {DomainObject | boolean}\n */\nfunction parseDomain(referrer) {\n  if (!referrer || !isBrowser) return false\n\n  let referringDomain = getDomainBase(referrer)\n  const a = document.createElement('a')\n  a.href = referrer\n\n  // Shim for the billion google search engines\n  if (a.hostname.indexOf(googleKey) > -1) {\n    referringDomain = googleKey\n  }\n\n  // If is search engine\n  if (searchEngines[referringDomain]) {\n    const searchEngine = searchEngines[referringDomain]\n    const queryParam = (typeof searchEngine === 'string') ? searchEngine : searchEngine.p\n    const termRegex = new RegExp(queryParam + '=.*?([^&#]*|$)', 'gi')\n    const term = a.search.match(termRegex)\n\n    return {\n      source: searchEngine.n || trimTld(referringDomain),\n      medium: 'organic',\n      term: (term ? term[0].split('=')[1] : '') || '(not provided)'\n    }\n  }\n\n  // Default\n  const medium = (!isExternalReferrer(referrer)) ? 'internal' : 'referral'\n  return {\n    source: a.hostname,\n    medium: medium\n  }\n}\n\n/**\n * Search engine query string data\n * @type {Object}\n */\nconst Q = 'q'\nconst QUERY = 'query'\nconst searchEngines = {\n  'daum.net': Q,\n  'eniro.se': 'search_word',\n  'naver.com': QUERY,\n  'yahoo.com': 'p',\n  'msn.com': Q,\n  'aol.com': Q,\n  'ask.com': Q,\n  'baidu.com': 'wd',\n  'yandex.com': 'text',\n  'rambler.ru': 'words',\n  'google': Q,\n  'bing.com': {\n    'p': Q,\n    'n': 'live'\n  },\n}\n", "/* ref: http://bit.ly/2daP79j */\n/**\n * @return {string}\n */\nexport function uuid() {\n  var u = '',\n  m = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx',\n  i = 0,\n  rb = Math.random() * 0xffffffff|0;\n\n  while (i++<36) {\n    var c = m [i-1],\n    r = rb&0xf,\n    v = c=='x' ? r : (r&0x3|0x8);\n\n    u += (c=='-' || c=='4') ? c : v.toString(16);\n    rb = i%8==0 ? Math.random() * 0xffffffff|0 : rb>>4\n  }\n  return u\n}\n", "/**\n * @template {Function} F;\n * @param {F} func;\n * @param {number} wait;\n * @return {F};\n */\nexport function throttle(func, wait) {\n  var context, args, result\n  var timeout = null\n  var previous = 0\n  var later = function () {\n    previous = new Date()\n    timeout = null\n    result = func.apply(context, args)\n  };\n  return function () {\n    var now = new Date()\n    if (!previous) {\n      previous = now\n    }\n    var remaining = wait - (now - previous)\n    context = this\n    args = arguments\n    if (remaining <= 0) {\n      clearTimeout(timeout)\n      timeout = null\n      previous = now\n      result = func.apply(context, args)\n    } else if (!timeout) {\n      timeout = setTimeout(later, remaining)\n    }\n    return result\n  }\n}\n", "import { OBJECT, PREFIX, UNDEFINED } from '@analytics/type-utils'\n\nexport const GLOBAL = 'global'\n\nexport const KEY = PREFIX + GLOBAL + PREFIX\n\nexport const globalContext = (typeof self === OBJECT && self.self === self && self) || (typeof global === OBJECT && global[GLOBAL] === global && global) || this\n\n/* initialize global object */\nif (!globalContext[KEY]) {\n  globalContext[KEY] = {}\n}\n/**\n * Get value from global context\n * @param {string} key - Key of value to get\n * @returns {*} value\n */\nexport function get(key) {\n  return globalContext[KEY][key]\n}\n\n/**\n * Set value to global context\n * @param {string} key - Key of value to set\n * @param {*} value \n * @returns value\n */\nexport function set(key, value) {\n  return globalContext[KEY][key] = value\n}\n\n/**\n * Remove value to global context\n * @param {string} key - Key of value to remove\n */\nexport function remove(key) {\n  delete globalContext[KEY][key]\n}\n\n/**\n * Wrap localStorage & session storage checks\n * @param {string} type - localStorage or sessionStorage\n * @param {string} storageOperation - getItem, setItem, removeItem\n * @param {function} fallbackFunction - fallback function\n */\nexport function wrap(type, operation, fallback) {\n  let fn\n  try {\n    if (hasSupport(type)) {\n      const storage = window[type]\n      fn = storage[operation].bind(storage)\n    }\n  } catch(e) {}\n  return fn || fallback\n}\n\nconst cache = {}\nexport function hasSupport(type) {\n  if (typeof cache[type] !== UNDEFINED) {\n    return cache[type]\n  }\n  try {\n    const storage = window[type]\n    // test for private safari\n    storage.setItem(UNDEFINED, UNDEFINED)\n    storage.removeItem(UNDEFINED)\n  } catch (err) {\n    return cache[type] = false\n  }\n  return cache[type] = true\n}\n\n/*\n// () => localStorage)\n// () => sessionStorage)\nexport function isSupported(getStorage) {\n  try {\n    const testKey = '__' + undef\n    getStorage().setItem(testKey, testKey)\n    getStorage().removeItem(testKey)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n*/\n", "export const FUNC = 'function'\nexport const UNDEF = 'undefined'\nexport const REDUCER = 'reducer'\n\nconst base = '@@redux/'\nexport const ACTION_INIT = base + 'INIT'\nexport const ACTION_TEST = base + Math.random().toString(36)\n", "import { isObject } from '@analytics/type-utils'\nimport { FUNC, UNDEF, ACTION_INIT, REDUCER } from './utils/defs'\n\n// eslint-disable-next-line\nconst $$observable = /* #__PURE__ */ (() => (typeof Symbol === FUNC && Symbol.observable) || '@@observable')();\n\n/*\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nconst msg = ' != ' + FUNC\nexport default function createStore(reducer, preloadedState, enhancer) {\n  if (typeof preloadedState === FUNC && typeof enhancer === UNDEF) {\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== UNDEF) {\n    if (typeof enhancer !== FUNC) {\n      throw new Error('enhancer' + msg)\n    }\n\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  if (typeof reducer !== FUNC) {\n    throw new Error(REDUCER + msg)\n  }\n\n  let currentReducer = reducer\n  let currentState = preloadedState\n  let currentListeners = []\n  let nextListeners = currentListeners\n  let isDispatching = false\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n\n  /*\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState\n  }\n\n  /*\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== FUNC) {\n      throw new Error('Listener' + msg)\n    }\n\n    let isSubscribed = true\n\n    ensureCanMutateNextListeners()\n    nextListeners.push(listener)\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return\n      }\n\n      isSubscribed = false\n\n      ensureCanMutateNextListeners()\n      const index = nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1)\n    }\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing \u201Cwhat changed\u201D. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    /* // add default info to actions... \n    console.log('dispatch before', _action)\n    const action = {\n      ..._action,\n      ...{\n        action: {\n          ..._action.action,\n          ...{ customInfo: 'yoooo'} \n        }\n      }\n    }\n    console.log('dispatch after', action)\n    /** */\n\n    if (!isObject(action)) {\n      throw new Error('Act != obj')\n    }\n\n    if (typeof action.type === UNDEF) {\n      throw new Error('ActType ' + UNDEF)\n    }\n\n    if (isDispatching) {\n      throw new Error('Dispatch in ' + REDUCER)\n    }\n\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n\n    const listeners = currentListeners = nextListeners\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== FUNC) {\n      throw new Error('next ' + REDUCER + msg)\n    }\n\n    currentReducer = nextReducer\n    dispatch({ type: ACTION_INIT })\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    const outerSubscribe = subscribe\n    return {\n      /*\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Observer != obj')\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState())\n          }\n        }\n\n        observeState()\n        const unsubscribe = outerSubscribe(observeState)\n        return { unsubscribe }\n      },\n\n      [$$observable]() {\n        return this\n      }\n    }\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ACTION_INIT })\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n}\n", "import { isObject } from '@analytics/type-utils'\nimport warning from './utils/warning'\nimport { FUNC, UNDEF, REDUCER, ACTION_INIT, ACTION_TEST } from './utils/defs'\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  const actionType = action && action.type\n  const actionName = (actionType && actionType.toString()) || '?'\n\n  return ('action ' + actionName + REDUCER + ' ' + key + ' returns ' + UNDEF)\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  const reducerKeys = Object.keys(reducers)\n  const argumentName = action && action.type === ACTION_INIT ? 'preloadedState arg passed to createStore' : 'previous state received by ' + REDUCER\n\n  if (reducerKeys.length === 0) {\n    return ('Store has no valid reducers')\n  }\n\n  if (!isObject(inputState)) {\n    return (\n      `The ${argumentName} has unexpected type of \"` +\n      ({}).toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] +\n      `\". Expected argument to be an object with the following ` +\n      `keys: \"${reducerKeys.join('\", \"')}\"`\n    )\n  }\n\n  const unexpectedKeys = Object.keys(inputState).filter(key =>\n    !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]\n  )\n\n  unexpectedKeys.forEach(key => {\n    unexpectedKeyCache[key] = true\n  })\n\n  if (unexpectedKeys.length > 0) {\n    return (\n      `Unexpected keys ${unexpectedKeys.join('\", \"')} in ${argumentName}. ` +\n      `Expected to find 1 of the known reducer keys instead: ${reducerKeys.join('\", \"')}`\n    )\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(key => {\n    const reducer = reducers[key]\n    const initialState = reducer(undefined, { type: ACTION_INIT })\n    if (\n      typeof initialState === UNDEF ||\n      typeof reducer(undefined, { type: ACTION_TEST }) === UNDEF\n    ) {\n      throw new Error(REDUCER + ' ' + key + ' ' + UNDEF)\n    }\n  })\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nexport default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n    if (NODE_ENV !== 'production') {\n      if (typeof reducers[key] === UNDEF) {\n        warning(`No reducer > ${key}`)\n      }\n    }\n\n    if (typeof reducers[key] === FUNC) {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  let unexpectedKeyCache\n  if (NODE_ENV !== 'production') {\n    unexpectedKeyCache = {}\n  }\n\n  let shapeAssertionError\n  try {\n    assertReducerShape(finalReducers)\n  } catch (e) {\n    shapeAssertionError = e\n  }\n\n  return function combination(state = {}, action) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    if (NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === UNDEF) {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    return hasChanged ? nextState : state\n  }\n}\n", "/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n", "import compose from './compose'\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nexport default function applyMiddleware(...middlewares) {\n  return (createStore) => (reducer, preloadedState, enhancer) => {\n    const store = createStore(reducer, preloadedState, enhancer)\n    let dispatch = store.dispatch\n    let chain = []\n\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action)\n    }\n    chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n", "/**\n * Core Analytic constants. These are exposed for third party plugins & listeners\n * @typedef {Object} constants\n * @property {ANON_ID} ANON_ID - Anonymous visitor Id localstorage key\n * @property {USER_ID} USER_ID - Visitor Id localstorage key\n * @property {USER_TRAITS} USER_TRAITS - Visitor traits localstorage key\n */\nimport { PREFIX } from '@analytics/type-utils'\n\n/**\n * Anonymous visitor Id localstorage key\n * @typedef {String} ANON_ID\n */\nexport const ANON_ID = PREFIX + 'anon_id' // __anon_id\n/**\n * Visitor Id localstorage key\n * @typedef {String} USER_ID\n */\nexport const USER_ID = PREFIX + 'user_id' // __user_id\n/**\n * Visitor traits localstorage key\n * @typedef {String} USER_TRAITS\n */\nexport const USER_TRAITS = PREFIX + 'user_traits' // __user_traits\n", "\nexport const LIB_NAME = 'analytics'\n\nexport const ID = 'userId'\n\nexport const ANONID = 'anonymousId'\n\nexport const ERROR_URL = 'https://lytics.dev/errors/'", "/* Core Analytic Events */\n\nexport const coreEvents = [\n  /**\n   * `bootstrap` - Fires when analytics library starts up.\n   * This is the first event fired. '.on/once' listeners are not allowed on bootstrap\n   * Plugins can attach logic to this event\n   */\n  'bootstrap',\n  /**\n   * `params` - Fires when analytics parses URL parameters\n   */\n  'params',\n  /**\n   * `campaign` - Fires if params contain \"utm\" parameters\n   */\n  'campaign',\n  /**\n   * `initializeStart` - Fires before 'initialize', allows for plugins to cancel loading of other plugins\n   */\n  'initializeStart',\n  /**\n   * `initialize` - Fires when analytics loads plugins\n   */\n  'initialize',\n  /**\n   * `initializeEnd` - Fires after initialize, allows for plugins to run logic after initialization methods run\n   */\n  'initializeEnd',\n  /**\n   * `ready` - Fires when all analytic providers are fully loaded. This waits for 'initialize' and 'loaded' to return true\n   */\n  'ready',\n  /**\n   * `resetStart` - Fires if analytic.reset() is called.\n   * Use this event to cancel reset based on a specific condition\n   */\n  'resetStart',\n  /**\n   * `reset` - Fires if analytic.reset() is called.\n   * Use this event to run custom cleanup logic (if needed)\n   */\n  'reset',\n  /**\n   * `resetEnd` - Fires after analytic.reset() is called.\n   * Use this event to run a callback after user data is reset\n   */\n  'resetEnd',\n  /******************\n   * Page Events\n   ******************/\n  /**\n   * `pageStart` - Fires before 'page' events fire.\n   *  This allows for dynamic page view cancellation based on current state of user or options passed in.\n   */\n  'pageStart',\n  /**\n   * `page` - Core analytics hook for page views.\n   *  If your plugin or integration tracks page views, this is the event to fire on.\n   */\n  'page',\n  /**\n   * `pageEnd` - Fires after all registered 'page' methods fire.\n   */\n  'pageEnd',\n  /**\n   * `pageAborted` - Fires if 'page' call is cancelled by a plugin\n   */\n  'pageAborted',\n  /****************\n   * Track Events\n   ***************/\n  /**\n   * `trackStart` - Called before the 'track' events fires.\n   *  This allows for dynamic page view cancellation based on current state of user or options passed in.\n   */\n  'trackStart',\n  /**\n   * `track` - Core analytics hook for event tracking.\n   *  If your plugin or integration tracks custom events, this is the event to fire on.\n   */\n  'track',\n  /**\n   * `trackEnd` - Fires after all registered 'track' events fire from plugins.\n   */\n  'trackEnd',\n  /**\n   * `trackAborted` - Fires if 'track' call is cancelled by a plugin\n   */\n  'trackAborted',\n  /******************\n   * Identify Events\n   ******************/\n  /**\n   * `identifyStart` - Called before the 'identify' events fires.\n   * This allows for dynamic page view cancellation based on current state of user or options passed in.\n   */\n  'identifyStart',\n  /**\n   * `identify` - Core analytics hook for user identification.\n   *  If your plugin or integration identifies users or user traits, this is the event to fire on.\n   */\n  'identify',\n  /**\n   * `identifyEnd` - Fires after all registered 'identify' events fire from plugins.\n   */\n  'identifyEnd',\n  /**\n   * `identifyAborted` - Fires if 'track' call is cancelled by a plugin\n   */\n  'identifyAborted',\n  /**\n   * `userIdChanged` - Fires when a user id is updated\n   */\n  'userIdChanged',\n  /******************\n   * Plugin Events\n   ******************/\n  /**\n   * `registerPlugins` - Fires when analytics is registering plugins\n   */\n  'registerPlugins',\n  /**\n   * `enablePlugin` - Fires when 'analytics.plugins.enable()' is called\n   */\n  'enablePlugin',\n  /**\n   * `disablePlugin` - Fires when 'analytics.plugins.disable()' is called\n   */\n  'disablePlugin',\n  /*\n   * `loadPlugin` - Fires when 'analytics.loadPlugin()' is called\n   */\n  // 'loadPlugin',\n  /******************\n   * Browser activity events\n   ******************/\n  /**\n   * `online` - Fires when browser network goes online.\n   * This fires only when coming back online from an offline state.\n   */\n  'online',\n  /**\n   * `offline` - Fires when browser network goes offline.\n   */\n  'offline',\n  /******************\n   * Storage events\n   ******************/\n  /**\n   * `setItemStart` - Fires when analytics.storage.setItem is initialized.\n   * This event gives plugins the ability to intercept keys & values and alter them before they are persisted.\n   */\n  'setItemStart',\n  /**\n   * `setItem` - Fires when analytics.storage.setItem is called.\n   * This event gives plugins the ability to intercept keys & values and alter them before they are persisted.\n   */\n  'setItem',\n  /**\n   * `setItemEnd` - Fires when setItem storage is complete.\n   */\n  'setItemEnd',\n  /**\n   * `setItemAborted` - Fires when setItem storage is cancelled by a plugin.\n   */\n  'setItemAborted',\n  /**\n   * `removeItemStart` - Fires when analytics.storage.removeItem is initialized.\n   * This event gives plugins the ability to intercept removeItem calls and abort / alter them.\n   */\n  'removeItemStart',\n  /**\n   * `removeItem` - Fires when analytics.storage.removeItem is called.\n   * This event gives plugins the ability to intercept removeItem calls and abort / alter them.\n   */\n  'removeItem',\n  /**\n   * `removeItemEnd` - Fires when removeItem storage is complete.\n   */\n  'removeItemEnd',\n  /**\n   * `removeItemAborted` - Fires when removeItem storage is cancelled by a plugin.\n   */\n  'removeItemAborted',\n]\n\n/* Keys on a plugin that are not considered events */\nexport const nonEvents = ['name', 'EVENTS', 'config', 'loaded']\n\nconst pluginEvents = {\n  registerPluginType: (name) => `registerPlugin:${name}`,\n  pluginReadyType: (name) => `ready:${name}`,\n}\n\nconst EVENTS = coreEvents.reduce((acc, curr) => {\n  acc[curr] = curr\n  return acc\n}, pluginEvents)\n\nexport default EVENTS\n\nexport function isReservedAction(type) {\n  return coreEvents.includes(type)\n}\n", "/* eslint-disable camelcase */\nimport EVENTS from '../events'\nimport { ANON_ID, USER_ID, USER_TRAITS } from '../constants'\n\nconst utmRegex = /^utm_/\nconst propRegex = /^an_prop_/\nconst traitRegex = /^an_trait_/\n\n// Middleware runs during EVENTS.initialize\nexport default function initializeMiddleware(instance) {\n  const { setItem } = instance.storage\n  return store => next => action => {\n    /* Handle bootstrap event */\n    if (action.type === EVENTS.bootstrap) {\n      const { params, user, persistedUser, initialUser } = action\n      const isKnownId = persistedUser.userId === user.userId\n      /* 1. Set anonymous ID */\n      if (persistedUser.anonymousId !== user.anonymousId) {\n        setItem(ANON_ID, user.anonymousId)\n      }\n      /* 2. Set userId */\n      if (!isKnownId) {\n        setItem(USER_ID, user.userId)\n      }\n      /* 3. Set traits if they are different */\n      if (initialUser.traits) {\n         setItem(USER_TRAITS, {\n          ...(isKnownId && persistedUser.traits) ? persistedUser.traits : {},\n          ...initialUser.traits\n        })\n        /* TODO multi user setup\n        setItem(`${USER_TRAITS}.${user.userId}`, {\n          ...(isKnownId) ? existingTraits : {},\n          ...initialUser.traits\n        })\n        */\n      }\n      /* 4. Parse url params */\n      const paramsArray = Object.keys(action.params)\n      if (paramsArray.length) {\n        const { an_uid, an_event } = params\n        const groupedParams = paramsArray.reduce((acc, key) => {\n          // match utm params & dclid (display) & gclid (cpc)\n          if (key.match(utmRegex) || key.match(/^(d|g)clid/)) {\n            const cleanName = key.replace(utmRegex, '')\n            const keyName = (cleanName === 'campaign') ? 'name' : cleanName\n            acc.campaign[keyName] = params[key]\n          }\n          if (key.match(propRegex)) {\n            acc.props[key.replace(propRegex, '')] = params[key]\n          }\n          if (key.match(traitRegex)) {\n            acc.traits[key.replace(traitRegex, '')] = params[key]\n          }\n          return acc\n        }, {\n          campaign: {},\n          props: {},\n          traits: {}\n        })\n\n        store.dispatch({\n          type: EVENTS.params,\n          raw: params,\n          ...groupedParams,\n          ...(an_uid ? { userId: an_uid } : {}),\n        })\n\n        /* If userId set, call identify */\n        if (an_uid) {\n          // timeout to debounce and make sure integration is registered. Todo refactor\n          setTimeout(() => instance.identify(an_uid, groupedParams.traits), 0)\n        }\n\n        /* If tracking event set, call track */\n        if (an_event) {\n          // timeout to debounce and make sure integration is registered. Todo refactor\n          setTimeout(() => instance.track(an_event, groupedParams.props), 0)\n        }\n\n        // if url has utm params\n        if (Object.keys(groupedParams.campaign).length) {\n          store.dispatch({\n            type: EVENTS.campaign,\n            campaign: groupedParams.campaign\n          })\n        }\n      }\n    }\n    return next(action)\n  }\n}\n", "import { get } from '@analytics/global-storage-utils'\nimport { isObject, PREFIX } from '@analytics/type-utils'\nimport { ANON_ID, USER_ID, USER_TRAITS } from '../constants'\nimport EVENTS from '../events'\n\n/* user reducer */\nexport default function userReducer(storage) {\n  return function user(state = {}, action = {}) {\n\n    if (action.type === EVENTS.setItemEnd) {\n      // Set anonymousId if changed by storage.setItem\n      if (action.key === ANON_ID) {\n        return { ...state, ...{ anonymousId: action.value }}\n      }\n      // Set userId if changed by storage.setItem\n      if (action.key === USER_ID) {\n        return { ...state, ...{ userId: action.value }}\n      }\n    }\n\n    switch (action.type) {\n      case EVENTS.identify:\n        return Object.assign({}, state, {\n          userId: action.userId,\n          traits: {\n            ...state.traits,\n            ...action.traits\n          }\n        })\n      case EVENTS.reset:\n        // Side effect to fix race condition in Node. TODO refactor\n        // This is from default storage.removeItem: (key) => globalContext[key] = undefined\n        [ USER_ID, ANON_ID, USER_TRAITS ].forEach((key) => {\n          // sync storage, not instance.storage\n          storage.removeItem(key)\n        })\n        return Object.assign({}, state, {\n          userId: null,\n          // TODO reset anon id automatically?\n          anonymousId: null,\n          traits: {},\n        })\n      default:\n        return state\n    }\n  }\n}\n\nexport function getPersistedUserData(storage) {\n  return {\n    userId: storage.getItem(USER_ID),\n    anonymousId: storage.getItem(ANON_ID),\n    traits: storage.getItem(USER_TRAITS)\n  }\n}\n\nexport const tempKey = (key) => PREFIX + 'TEMP' + PREFIX + key\n\nexport function getUserPropFunc(storage) {\n  return function getUserProp(key, instance, payload) {\n    /* 1. Try current state */\n    const currentId = instance.getState('user')[key]\n    if (currentId) {\n      /*\n      console.log(`from state ${key}`, currentId)\n      /** */\n      return currentId\n    }\n\n    /* 2. Try event payload */\n    if (payload && isObject(payload) && payload[key]) {\n      /*\n      console.log(`from payload ${key}`, payload[key])\n      /** */\n      return payload[key]\n    }\n\n    /* 3. Try persisted data */\n    const persistedInfo = getPersistedUserData(storage)[key]\n    if (persistedInfo) {\n      /*\n      console.log(`from persistedInfo ${key}`, persistedInfo)\n      /** */\n      return persistedInfo\n    }\n\n    /* 4. Else, try to get in memory placeholder. TODO watch this for future issues */\n    return get(tempKey(key)) || null\n  }\n}\n", "import { uuid } from 'analytics-utils'\nimport { remove } from '@analytics/global-storage-utils'\nimport { tempKey } from '../modules/user'\nimport { USER_ID, USER_TRAITS, ANON_ID } from '../constants'\nimport { ID, ANONID } from '../utils/internalConstants'\nimport EVENTS from '../events'\n\nexport default function identifyMiddleware(instance) {\n  const { setItem, removeItem, getItem } = instance.storage\n  return store => next => action => {\n    const { userId, traits, options } = action\n    /* Reset user id and traits */\n    if (action.type === EVENTS.reset) {\n      // Remove stored data\n      [ USER_ID, USER_TRAITS, ANON_ID ].forEach((key) => {\n        // Fires async removeItem dispatch\n        removeItem(key)\n      });\n      [ ID, ANONID, 'traits' ].forEach((key) => {\n        // Remove from global context\n        remove(tempKey(key))\n      })\n    }\n\n    if (action.type === EVENTS.identify) {\n      /* If no anon id. Set it! */\n      if (!getItem(ANON_ID)) {\n        setItem(ANON_ID, uuid())\n      }\n\n      const currentId = getItem(USER_ID)\n      const currentTraits = getItem(USER_TRAITS) || {}\n\n      if (currentId && (currentId !== userId)) {\n        store.dispatch({\n          type: EVENTS.userIdChanged,\n          old: {\n            userId: currentId,\n            traits: currentTraits,\n          },\n          new: {\n            userId,\n            traits\n          },\n          options: options,\n        })\n      }\n\n      /* Save user id */\n      if (userId) {\n        setItem(USER_ID, userId)\n      }\n\n      /* Save user traits */\n      if (traits) {\n        setItem(USER_TRAITS, {\n          ...currentTraits,\n          ...traits\n        })\n      }\n    }\n    return next(action)\n  }\n}\n", "import { isFunction } from '@analytics/type-utils'\n\n// Stack to temporarily hold deferred promises/callbacks\nconst stack = {}\n\nfunction runCallback(id, payload) {\n  if (stack[id] && isFunction(stack[id])) {\n    // console.log(`run ${id}`)\n    stack[id](payload)\n    delete stack[id]\n  }\n}\n\nexport { stack, runCallback }", "/**\n * Wait until a given analytics provider is ready.\n * @param  {Object} data - passthrough resolve data\n * @param  {Function} predicate - function that resolves true\n * @param  {Number} timeout - max wait time\n * @return {Promise}\n */\nexport default function waitForReady(data, predicate, timeout) {\n  return new Promise((resolve, reject) => {\n    if (predicate()) {\n      return resolve(data)\n    }\n    // Timeout. Add to queue\n    if (timeout < 1) {\n      return reject({ ...data, queue: true }) // eslint-disable-line\n    }\n    // Else recursive retry\n    return pause(10).then(_ => {\n      return waitForReady(data, predicate, timeout - 10).then(resolve, reject)\n    })\n  })\n}\n\nfunction pause(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n", "import { isFunction } from '@analytics/type-utils'\nimport { ID, ANONID } from './internalConstants'\n\nexport function processQueue(store, getPlugins, instance) {\n  const pluginMethods = getPlugins()\n  const { plugins, context, queue, user } = store.getState()\n  const isOnline = !context.offline\n  /* If network connection found and there is items in queue, process them all */\n  if (isOnline && queue && queue.actions && queue.actions.length) {\n    const pipeline = queue.actions.reduce((acc, item, index) => {\n      const isLoaded = plugins[item.plugin].loaded\n      if (isLoaded) {\n        acc.process.push(item)\n        acc.processIndex.push(index)\n      } else {\n        acc.requeue.push(item)\n        acc.requeueIndex.push(index)\n      }\n      return acc\n    }, {\n      processIndex: [],\n      process: [],\n      requeue: [],\n      requeueIndex: []\n    })\n\n    if (pipeline.processIndex && pipeline.processIndex.length) {\n      pipeline.processIndex.forEach((i) => {\n        const processAction = queue.actions[i]\n        // console.log('RePROCESS THIS>', processAction)\n        // Call methods directly right now\n        const currentPlugin = processAction.plugin\n        const currentMethod = processAction.payload.type\n        const method = pluginMethods[currentPlugin][currentMethod]\n        if (method && isFunction(method)) {\n          /* enrich queued payload with userId / anon id if missing */\n          /* TODO hoist enrich into where action queued? */\n          // console.log('before', processAction.payload)\n          const enrichedPayload = enrich(processAction.payload, user)\n          // console.log('user.userId', user.userId)\n          // console.log('user.anonymousId', user.anonymousId)\n          // console.log('after enrich', enrichedPayload)\n          method({\n            payload: enrichedPayload,\n            config: plugins[currentPlugin].config,\n            instance,\n          })\n\n          /* Then redispatch for .on listeners / other middleware */\n          const pluginEvent = `${currentMethod}:${currentPlugin}`\n          store.dispatch({\n            ...enrichedPayload,\n            type: pluginEvent,\n            /* Internal data for analytics engine */\n            _: {\n              called: pluginEvent,\n              from: 'queueDrain'\n            }\n          })\n        }\n      })\n\n      /* Removed processed actions */\n      const reQueueActions = queue.actions.filter((value, index) => {\n        // note !~ === return pipeline.processIndex.indexOf(index) === -1\n        return !~pipeline.processIndex.indexOf(index)\n      })\n\n      /* Set queue actions. TODO refactor to non mutatable or move out of redux */\n      queue.actions = reQueueActions\n    }\n  }\n}\n\n/* Heartbeat retries queued events */\nexport default function heartBeat(store, getPlugins, instance) {\n  // 3e3 === 3000 ms\n  return setInterval(() => processQueue(store, getPlugins, instance), 3e3)\n}\n\n// Assign userId && anonymousId values if present in payload but null\nfunction enrich(payload = {}, user = {}) {\n  return [ ID, ANONID ].reduce((acc, key) => {\n    if (payload.hasOwnProperty(key) && user[key] && (user[key] !== payload[key])) {\n      // console.log(`${key} stale update with ${user[key]}`)\n      acc[key] = user[key]\n    }\n    return acc\n  }, payload)\n}\n", "import EVENTS from '../../events'\nimport fitlerDisabledPlugins from '../../utils/filterDisabled'\nimport { isFunction, isObject, isString } from '@analytics/type-utils'\nimport { runCallback } from '../../utils/callback-stack'\n\nconst endsWithStartRegex = /Start$/\nconst bootstrapRegex = /^bootstrap/\nconst readyRegex = /^ready/\n\nexport default async function (action, getPlugins, instance, store, eventsInfo) {\n  const pluginObject = isFunction(getPlugins) ? getPlugins() : getPlugins\n  const originalType = action.type\n  const updatedType = originalType.replace(endsWithStartRegex, '')\n\n  /* If action already dispatched exit early. This makes it so plugin methods are not fired twice. */\n  if (action._ && action._.called) {\n    // console.log('Already called', action._.called)\n    return action\n  }\n\n  const state = instance.getState()\n  /* Remove plugins that are disabled by options or by settings */\n  let activePlugins = fitlerDisabledPlugins(pluginObject, state.plugins, action.options)\n\n  /* If analytics.plugin.enable calls do special behavior */\n  if (originalType === EVENTS.initializeStart && action.fromEnable) {\n    // Return list of all enabled plugins that have NOT been initialized yet\n    activePlugins = Object.keys(state.plugins).filter((name) => {\n      const info = state.plugins[name]\n      return action.plugins.includes(name) && !info.initialized\n    }).map((name) => pluginObject[name])\n  }\n  // console.log(`engine activePlugins ${action.type}`, activePlugins)\n\n  const allActivePluginKeys = activePlugins.map((p) => p.name)\n  // console.log('allActivePluginKeys', allActivePluginKeys)\n  const allMatches = getAllMatchingCalls(originalType, activePlugins, pluginObject)\n  // console.log('allMatches', allMatches)\n\n  /* @TODO cache matches and purge on enable/disable/add plugin */\n\n  /**\n   * Process all 'actionBefore' hooks\n   * Example:\n   *  This is processes 'pageStart' methods from plugins and update the event to send through the chain\n   */\n  const actionBefore = await processEvent({\n    action: action,\n    data: {\n      exact: allMatches.before,\n      namespaced: allMatches.beforeNS\n    },\n    state: state,\n    allPlugins: pluginObject,\n    allMatches,\n    instance,\n    store,\n    EVENTS: eventsInfo\n  })\n  // console.log('____ actionBefore out', actionBefore)\n\n  /* Abort if \u2018eventBefore\u2019 returns abort data */\n  if (shouldAbortAll(actionBefore, allActivePluginKeys.length)) {\n    return actionBefore\n  }\n\n  /* Filter over the plugin method calls and remove aborted plugin by name */\n  // const activeAndNonAbortedCalls = activePlugins.filter((plugin) => {\n  //   if (shouldAbort(actionBefore, plugin.name)) return false\n  //   return true\n  // })\n  // console.log(`activeAndNonAbortedCalls ${action.type}`, activeAndNonAbortedCalls)\n\n  let actionDuring\n  if (originalType === updatedType) {\n    /* If type the same don't double process */\n    actionDuring = actionBefore\n  } else {\n    /**\n     * Process all 'action' hooks\n     * Example: This is process 'page' methods from plugins and update the event to send through\n     */\n    actionDuring = await processEvent({\n      action: {\n        ...actionBefore,\n        type: updatedType\n      },\n      data: {\n        exact: allMatches.during,\n        namespaced: allMatches.duringNS\n      },\n      state: state,\n      allPlugins: pluginObject,\n      allMatches,\n      instance,\n      store,\n      EVENTS: eventsInfo\n    })\n  }\n  // console.log('____ actionDuring', actionDuring)\n\n  /**\n   * Process all 'actionEnd' hooks\n   * Example:\n   *  This is process 'pageEnd' methods from plugins and update the event to send through\n   */\n  // Only trigger `eventTypeEnd` if originalAction has Start ending.\n  if (originalType.match(endsWithStartRegex)) {\n    const afterName = `${updatedType}End`\n    const actionAfter = await processEvent({\n      action: {\n        ...actionDuring,\n        type: afterName\n      },\n      data: {\n        exact: allMatches.after,\n        namespaced: allMatches.afterNS\n      },\n      state: state,\n      allPlugins: pluginObject,\n      allMatches,\n      instance,\n      store,\n      EVENTS: eventsInfo\n    })\n    // console.log('____ actionAfter', actionAfter)\n\n    /* Fire callback if supplied */\n    if (actionAfter.meta && actionAfter.meta.hasCallback) {\n      /*\n      console.log('End of engine action has callback')\n      console.log(actionAfter.meta)\n      console.log('stack', stack)\n      /** */\n\n      // @TODO figure out exact args calls and .on will get\n      runCallback(actionAfter.meta.rid, { payload: actionAfter })\n    }\n  }\n\n  return actionBefore\n}\n\n/**\n * Async reduce over matched plugin methods\n * Fires plugin functions\n */\nasync function processEvent({\n  data,\n  action,\n  instance,\n  state,\n  allPlugins,\n  allMatches,\n  store,\n  EVENTS\n}) {\n  const { plugins, context } = state\n  const method = action.type\n  const isStartEvent = method.match(endsWithStartRegex)\n  // console.log(`data ${method}`, data)\n  // console.log(`data allMatches ${method}`, allMatches)\n  let abortable = data.exact.map((x) => {\n    return x.pluginName\n  })\n\n  /* If abort is called from xyzStart */\n  if (isStartEvent) {\n    abortable = allMatches.during.map((x) => {\n      return x.pluginName\n    })\n  }\n\n  /* make args for functions to concume */\n  const makeArgs = argumentFactory(instance, abortable)\n  // console.log('makeArgs', makeArgs)\n\n  /* Check if plugin loaded, if not mark action for queue */\n  const queueData = data.exact.reduce((acc, thing) => {\n    const { pluginName, methodName } = thing\n    let addToQueue = false\n    // Queue actions if plugin not loaded except for initialize and reset\n    if (!methodName.match(/^initialize/) && !methodName.match(/^reset/)) {\n      addToQueue = !plugins[pluginName].loaded\n    }\n    /* If offline and its a core method. Add to queue */\n    if (context.offline && (methodName.match(/^(page|track|identify)/))) {\n      addToQueue = true\n    }\n    acc[`${pluginName}`] = addToQueue\n    return acc\n  }, {})\n\n  /* generate plugin specific payloads */\n  const payloads = await data.exact.reduce(async (scoped, curr, i) => {\n    const { pluginName } = curr\n    const curScope = await scoped\n    if (data.namespaced && data.namespaced[pluginName]) {\n      const scopedPayload = await data.namespaced[pluginName].reduce(async (acc, p, count) => {\n        // await value\n        const curScopeData = await acc\n        if (!p.method || !isFunction(p.method)) {\n          return curScopeData\n        }\n\n        /* Make sure plugins don\u2019t call themselves */\n        validateMethod(p.methodName, p.pluginName)\n\n        function genAbort(currentAct, pname, otherPlug) {\n          return function (reason, plugins) {\n            const callsite = otherPlug || pname\n            // console.log(`__abort msg: ${reason}`)\n            // console.log(`__abort ${pname}`)\n            // console.log(`__abort xxx: ${plugins}`)\n            // console.log(`__abort otherPlug`, otherPlug)\n            return {\n              ...currentAct,\n              abort: {\n                reason: reason,\n                plugins: plugins || [pname],\n                caller: method,\n                from: callsite\n              }\n            }\n          }\n        }\n\n        const val = await p.method({\n          payload: curScopeData,\n          instance,\n          abort: genAbort(curScopeData, pluginName, p.pluginName),\n          config: getConfig(p.pluginName, plugins, allPlugins),\n          plugins: plugins\n        })\n        const returnValue = isObject(val) ? val : {}\n        return Promise.resolve({\n          ...curScopeData,\n          ...returnValue\n        })\n      }, Promise.resolve(action))\n\n      /* Set scoped payload */\n      curScope[pluginName] = scopedPayload\n    } else {\n      /* Set payload as default action */\n      curScope[pluginName] = action\n    }\n    return Promise.resolve(curScope)\n  }, Promise.resolve({}))\n  // console.log(`aaa scoped payloads ${action.type}`, payloads)\n\n  // Then call the normal methods with scoped payload\n  const resolvedAction = await data.exact.reduce(async (promise, curr, i) => {\n    const lastLoop = data.exact.length === (i + 1)\n    const { pluginName } = curr\n    const currentPlugin = allPlugins[pluginName]\n    const currentActionValue = await promise\n\n    let payloadValue = (payloads[pluginName]) ? payloads[pluginName] : {}\n    /* If eventStart, allow for value merging */\n    if (isStartEvent) {\n      payloadValue = currentActionValue\n    }\n\n    if (shouldAbort(payloadValue, pluginName)) {\n      // console.log(`> Abort from payload specific \"${pluginName}\" abort value`, payloadValue)\n      abortDispatch({\n        data: payloadValue,\n        method,\n        instance,\n        pluginName,\n        store\n      })\n      return Promise.resolve(currentActionValue)\n    }\n    if (shouldAbort(currentActionValue, pluginName)) {\n      // console.log(`> Abort from ${method} abort value`, currentActionValue)\n      if (lastLoop) {\n        abortDispatch({\n          data: currentActionValue,\n          method,\n          instance,\n          // pluginName,\n          store\n        })\n      }\n      return Promise.resolve(currentActionValue)\n    }\n\n    if (queueData.hasOwnProperty(pluginName) && queueData[pluginName] === true) {\n      // console.log('Queue this instead', pluginName)\n      store.dispatch({\n        type: `queue`,\n        plugin: pluginName,\n        payload: payloadValue,\n        /* Internal data for analytics engine */\n        _: {\n          called: `queue`,\n          from: 'queueMechanism' // for debugging\n        }\n      })\n      return Promise.resolve(currentActionValue)\n    }\n    /*\n    const checkForLoaded = () => {\n      const p = instance.getState('plugins')\n      return p[currentPlugin.name].loaded\n    }\n    // const p = instance.getState('plugins')\n    console.log(`loaded \"${currentPlugin.name}\" > ${method}:`, p[currentPlugin.name].loaded)\n    // await waitForReady(currentPlugin, checkForLoaded, 10000).then((d) => {\n    //   console.log(`Loaded ${method}`, currentPlugin.name)\n    // }).catch((e) => {\n    //   console.log(`Error ${method} ${currentPlugin.name}`, e)\n    //   // TODO dispatch failure\n    // })\n    */\n\n    // @TODO figure out if we want queuing semantics\n\n    const funcArgs = makeArgs(payloads[pluginName], allPlugins[pluginName])\n\n    // console.log(`funcArgs ${method} ${pluginName}`, funcArgs)\n\n    /* Run the plugin function */\n    const val = await currentPlugin[method]({\n      // currentPlugin: pluginName,\n      abort: funcArgs.abort,\n      // Send in original action value or scope payload\n      payload: payloadValue,\n      instance,\n      config: getConfig(pluginName, plugins, allPlugins),\n      plugins: plugins\n    })\n\n    const returnValue = isObject(val) ? val : {}\n    const merged = {\n      ...currentActionValue,\n      ...returnValue\n    }\n\n    const scopedPayload = payloads[pluginName] // || currentActionValue\n    if (shouldAbort(scopedPayload, pluginName)) {\n      // console.log(`>> HANDLE abort ${method} ${pluginName}`)\n      abortDispatch({\n        data: scopedPayload,\n        method,\n        instance,\n        pluginName,\n        store\n      })\n    } else {\n      const nameSpaceEvent = `${method}:${pluginName}`\n      const actionDepth = (nameSpaceEvent.match(/:/g) || []).length\n      if (actionDepth < 2 && !method.match(bootstrapRegex) && !method.match(readyRegex)) {\n        const updatedPayload = (isStartEvent) ? merged : payloadValue\n        // Dispatched for `.on('xyz') listeners.\n        instance.dispatch({\n          ...updatedPayload,\n          type: nameSpaceEvent,\n          _: {\n            called: nameSpaceEvent,\n            from: 'submethod'\n          }\n        })\n      }\n    }\n    // console.log('merged', merged)\n    return Promise.resolve(merged)\n  }, Promise.resolve(action))\n\n  // Dispatch End. Make sure actions don't get double dispatched. EG userIdChanged\n  if (!method.match(endsWithStartRegex) &&\n      !method.match(/^registerPlugin/) &&\n      // !method.match(/^disablePlugin/) &&\n      // !method.match(/^enablePlugin/) &&\n      !method.match(readyRegex) &&\n      !method.match(bootstrapRegex) &&\n      !method.match(/^params/) &&\n      !method.match(/^userIdChanged/)\n  ) {\n    if (EVENTS.plugins.includes(method)) {\n      // console.log(`Dont dispatch for ${method}`, resolvedAction)\n      // return resolvedAction\n    }\n    /*\n      Verify this original action setup.\n      It's intended to keep actions from double dispatching themselves\n    */\n    if (resolvedAction._ && resolvedAction._.originalAction === method) {\n      // console.log(`Dont dispatch for ${method}`, resolvedAction)\n      return resolvedAction\n    }\n\n    let endAction = {\n      ...resolvedAction,\n      ...{\n        _: {\n          originalAction: resolvedAction.type,\n          called: resolvedAction.type,\n          from: 'engineEnd'\n        }\n      }\n    }\n\n    /* If all plugins are aborted, dispatch xAborted */\n    if (shouldAbortAll(resolvedAction, data.exact.length) && !method.match(/End$/)) {\n      endAction = {\n        ...endAction,\n        ...{\n          type: resolvedAction.type + 'Aborted',\n        }\n      }\n    }\n\n    store.dispatch(endAction)\n  }\n\n  return resolvedAction\n}\n\nfunction abortDispatch({ data, method, instance, pluginName, store }) {\n  const postFix = (pluginName) ? ':' + pluginName : ''\n  const abortEvent = method + 'Aborted' + postFix\n  store.dispatch({\n    ...data,\n    type: abortEvent,\n    _: {\n      called: abortEvent,\n      from: 'abort'\n    }\n  })\n}\n\nfunction getConfig(name, pluginState, allPlugins) {\n  const pluginData = pluginState[name] || allPlugins[name]\n  if (pluginData && pluginData.config) {\n    return pluginData.config\n  }\n  return {}\n}\n\nfunction getPluginFunctions(methodName, plugins) {\n  return plugins.reduce((arr, plugin) => {\n    return (!plugin[methodName]) ? arr : arr.concat({\n      methodName: methodName,\n      pluginName: plugin.name,\n      method: plugin[methodName],\n    })\n  }, [])\n}\n\nfunction formatMethod(type) {\n  return type.replace(endsWithStartRegex, '')\n}\n\n/**\n * Return array of event names\n * @param  {String} eventType - original event type\n * @param  {String} namespace - optional namespace postfix\n * @return {array} - type, method, end\n */\nfunction getEventNames(eventType, namespace) {\n  const method = formatMethod(eventType)\n  const postFix = (namespace) ? `:${namespace}` : ''\n  // `typeStart:pluginName`\n  const type = `${eventType}${postFix}`\n  // `type:pluginName`\n  const methodName = `${method}${postFix}`\n  // `typeEnd:pluginName`\n  const end = `${method}End${postFix}`\n  return [ type, methodName, end ]\n}\n\n/* Collect all calls for a given event in the system */\nfunction getAllMatchingCalls(eventType, activePlugins, allPlugins) {\n  const eventNames = getEventNames(eventType)\n  // console.log('eventNames', eventNames)\n  // 'eventStart', 'event', & `eventEnd`\n  const core = eventNames.map((word) => {\n    return getPluginFunctions(word, activePlugins)\n  })\n  // Gather nameSpaced Events\n  return activePlugins.reduce((acc, plugin) => {\n    const { name } = plugin\n    const nameSpacedEvents = getEventNames(eventType, name)\n    // console.log('eventNames namespaced', nameSpacedEvents)\n    const [ beforeFuncs, duringFuncs, afterFuncs ] = nameSpacedEvents.map((word) => {\n      return getPluginFunctions(word, activePlugins)\n    })\n\n    if (beforeFuncs.length) {\n      acc.beforeNS[name] = beforeFuncs\n    }\n    if (duringFuncs.length) {\n      acc.duringNS[name] = duringFuncs\n    }\n    if (afterFuncs.length) {\n      acc.afterNS[name] = afterFuncs\n    }\n    return acc\n  }, {\n    before: core[0],\n    beforeNS: {},\n    during: core[1],\n    duringNS: {},\n    after: core[2],\n    afterNS: {}\n  })\n}\n\nfunction shouldAbort({ abort }, pluginName) {\n  if (!abort) return false\n  if (abort === true) return true\n  return includes(abort, pluginName) || (abort && includes(abort.plugins, pluginName))\n}\n\nfunction shouldAbortAll({ abort }, pluginsCount) {\n  if (!abort) return false\n  if (abort === true || isString(abort)) return true\n  const { plugins } = abort\n  return (isArray(abort) && (abort.length === pluginsCount)) || (isArray(plugins) && (plugins.length === pluginsCount))\n}\n\nfunction isArray(arr) {\n  return Array.isArray(arr)\n}\n\nfunction includes(arr, name) {\n  if (!arr || !isArray(arr)) return false\n  return arr.includes(name)\n}\n\n/**\n * Generate arguments to pass to plugin methods\n * @param  {Object} instance - analytics instance\n * @param  {array} abortablePlugins - plugins that can be cancelled by caller\n * @return {*} function to inject plugin params\n */\nfunction argumentFactory(instance, abortablePlugins) {\n  // console.log('abortablePlugins', abortablePlugins)\n  return function (action, plugin, otherPlugin) {\n    const { config, name } = plugin\n    let method = `${name}.${action.type}`\n    if (otherPlugin) {\n      method = otherPlugin.event\n    }\n\n    const abortF = (action.type.match(endsWithStartRegex))\n      ? abortFunction(name, method, abortablePlugins, otherPlugin, action)\n      : notAbortableError(action, method)\n\n    return {\n      /* self: plugin, for future maybe */\n      // clone objects to avoid reassign\n      payload: formatPayload(action),\n      instance: instance,\n      config: config || {},\n      abort: abortF\n    }\n  }\n}\n\nfunction abortFunction(pluginName, method, abortablePlugins, otherPlugin, action) {\n  return function (reason, plugins) {\n    const caller = (otherPlugin) ? otherPlugin.name : pluginName\n    let pluginsToAbort = (plugins && isArray(plugins)) ? plugins : abortablePlugins\n    if (otherPlugin) {\n      pluginsToAbort = (plugins && isArray(plugins)) ? plugins : [pluginName]\n      if (!pluginsToAbort.includes(pluginName) || pluginsToAbort.length !== 1) {\n        throw new Error(`Method ${method} can only abort ${pluginName} plugin. ${JSON.stringify(pluginsToAbort)} input valid`)\n      }\n    }\n    return {\n      ...action, // \uD83D\uDD25 todo verify this merge is ok\n      abort: {\n        reason: reason,\n        plugins: pluginsToAbort,\n        caller: method,\n        _: caller\n      }\n    }\n  }\n}\n\nfunction notAbortableError(action, method) {\n  return () => {\n    throw new Error(action.type + ' action not cancellable. Remove abort in ' + method)\n  }\n}\n\n/**\n * Verify plugin is not calling itself with whatever:myPluginName self refs\n */\nfunction validateMethod(actionName, pluginName) {\n  const text = getNameSpacedAction(actionName)\n  const methodCallMatchesPluginNamespace = text && (text.name === pluginName)\n  if (methodCallMatchesPluginNamespace) {\n    const sub = getNameSpacedAction(text.method)\n    const subText = (sub) ? 'or ' + sub.method : ''\n    throw new Error([ pluginName + ' plugin is calling method ' + actionName,\n      'Plugins cant call self',\n      `Use ${text.method} ${subText} in ${pluginName} plugin insteadof ${actionName}`]\n      .join('\\n')\n    )\n  }\n}\n\nfunction getNameSpacedAction(event) {\n  const split = event.match(/(.*):(.*)/)\n  if (!split) {\n    return false\n  }\n  return {\n    method: split[1],\n    name: split[2],\n  }\n}\n\nfunction formatPayload(action) {\n  return Object.keys(action).reduce((acc, key) => {\n    // redact type from { payload }\n    if (key === 'type') {\n      return acc\n    }\n    if (isObject(action[key])) {\n      acc[key] = Object.assign({}, action[key])\n    } else {\n      acc[key] = action[key]\n    }\n    return acc\n  }, {})\n}\n\n/*\nfunction getMatchingMethods(eventType, activePlugins) {\n  const exact = getPluginFunctions(eventType, activePlugins)\n  // console.log('exact', exact)\n  // Gather nameSpaced Events\n  return activePlugins.reduce((acc, plugin) => {\n    const { name } = plugin\n    const clean = getPluginFunctions(`${eventType}:${name}`, activePlugins)\n    if (clean.length) {\n      acc.namespaced[name] = clean\n    }\n    return acc\n  }, {\n    exact: exact,\n    namespaced: {}\n  })\n}\n*/\n", "import EVENTS, { nonEvents } from '../../events'\nimport { runCallback, stack } from '../../utils/callback-stack'\nimport waitForReady from '../../utils/waitForReady'\nimport { processQueue } from '../../utils/heartbeat'\nimport runPlugins from './engine'\n\nexport default function pluginMiddleware(instance, getPlugins, systemEvents) {\n  const isReady = {}\n  return store => next => async action => {\n    const { type, abort, plugins } = action\n    let updatedAction = action\n\n    if (abort) {\n      return next(action)\n    }\n\n    /* Analytics.plugins.enable called, we need to init the plugins */\n    if (type === EVENTS.enablePlugin) {\n      store.dispatch({\n        type: EVENTS.initializeStart,\n        plugins: plugins,\n        disabled: [],\n        fromEnable: true,\n        meta: action.meta\n      })\n    }\n    \n    if (type === EVENTS.disablePlugin) {\n      // If cached callback, resolve promise/run callback. debounced to fix race condition\n      setTimeout(() => runCallback(action.meta.rid, { payload: action }), 0)\n    }\n\n    /* @TODO implement\n    if (type === EVENTS.loadPlugin) {\n      // Rerun initialize calls in plugins\n      const allPlugins = getPlugins()\n      const pluginsToLoad = Object.keys(allPlugins).filter((name) => {\n        return plugins.includes(name)\n      }).reduce((acc, curr) => {\n        acc[curr] = allPlugins[curr]\n        return acc\n      }, {})\n      const initializeAction = {\n        type: EVENTS.initializeStart,\n        plugins: plugins\n      }\n      const updated = await runPlugins(initializeAction, pluginsToLoad, instance, store, systemEvents)\n      return next(updated)\n    }\n    */\n\n    //  || type.match(/^initializeAbort:/)\n    if (type === EVENTS.initializeEnd) {\n      const allPlugins = getPlugins()\n      const pluginsArray = Object.keys(allPlugins)\n      const allRegisteredPlugins = pluginsArray.filter((name) => {\n        return plugins.includes(name)\n      }).map((name) => {\n        return allPlugins[name]\n      })\n      let completed = []\n      let failed = []\n      let disabled = action.disabled\n      // console.log('allRegisteredPlugins', allRegisteredPlugins)\n      const waitForPluginsToLoad = allRegisteredPlugins.map((plugin) => {\n        const { loaded, name } = plugin\n        /* Plugins will abort trying to load after 10 seconds. 1e4 === 10000 MS */\n        return waitForReady(plugin, loaded, 1e4).then((d) => {\n          if (!isReady[name]) {\n            // only dispatch namespaced rdy once\n            store.dispatch({\n              type: EVENTS.pluginReadyType(name), // `ready:${name}`\n              name: name,\n              events: Object.keys(plugin).filter((name) => {\n                return !nonEvents.includes(name)\n              })\n            })\n            isReady[name] = true\n          }\n          completed = completed.concat(name)\n\n          return plugin\n          // It's loaded! run the command\n        }).catch((e) => {\n          // Timeout Add to queue\n          // console.log('Error generic waitForReady. Push this to queue', e)\n          if (e instanceof Error) {\n            throw new Error(e)\n          }\n          failed = failed.concat(e.name)\n          // Failed to fire, add to queue\n          return e\n        })\n      })\n\n      Promise.all(waitForPluginsToLoad).then((calls) => {\n        // setTimeout to ensure runs after 'page'\n        const payload = {\n          plugins: completed,\n          failed: failed,\n          disabled: disabled\n        }\n        setTimeout(() => {\n          if (pluginsArray.length === (waitForPluginsToLoad.length + disabled.length)) {\n            store.dispatch({\n              ...{ type: EVENTS.ready },\n              ...payload,\n              \n            })\n          }\n        }, 0)\n      })\n    }\n\n    /* New plugin system */\n    if (type !== EVENTS.bootstrap) {\n      if (/^ready:([^:]*)$/.test(type)) {\n        // Immediately flush queue\n        setTimeout(() => processQueue(store, getPlugins, instance), 0)\n      }\n      const updated = await runPlugins(action, getPlugins, instance, store, systemEvents)\n      return next(updated)\n    }\n\n    return next(updatedAction)\n  }\n}\n", "import { isBoolean } from '@analytics/type-utils'\n\nexport default function fitlerDisabledPlugins(allPlugins, settings = {}, options = {}) {\n  return Object.keys(allPlugins).filter((name) => {\n    const fromCallOptions = options.plugins || {}\n    // If enabled/disabled by options. Override settings\n    if (isBoolean(fromCallOptions[name])) {\n      return fromCallOptions[name]\n    }\n    // If all: false disable everything unless true explicitly set\n    if (fromCallOptions.all === false) {\n      return false\n    }\n    // else use state.plugin settings\n    if (settings[name] && settings[name].enabled === false) {\n      return false\n    }\n    return true\n  }).map((name) => allPlugins[name])\n}\n", "import EVENTS from '../events'\n\nexport default function storageMiddleware(storage) {\n  return store => next => action => {\n    const { type, key, value, options } = action\n    if (type === EVENTS.setItem || type === EVENTS.removeItem) {\n      if (action.abort) {\n        return next(action)\n      }\n      // Run storage set or remove\n      if (type === EVENTS.setItem) {\n        storage.setItem(key, value, options)\n      } else {\n        storage.removeItem(key, options)\n      }\n    }\n    return next(action)\n  }\n}\n\n/*\n  Todo: emit events for keys we care about\n  window.addEventListener('storage', (event) => console.log(event));\n*/\n", "import { compose } from '../vendor/redux'\n\n/* Class to fix dynamic middlewares from conflicting with each other\nif more than one analytic instance is active */\nexport default class DynamicMiddleware {\n  before = []\n  after = []\n  addMiddleware = (middlewares, position) => {\n    this[position] = this[position].concat(middlewares)\n  }\n  removeMiddleware = (middleware, position) => {\n    const index = this[position].findIndex(d => d === middleware)\n    if (index === -1) return\n\n    this[position] = [\n      ...this[position].slice(0, index),\n      ...this[position].slice(index + 1),\n    ]\n  }\n  /* Not currently in use\n  resetMiddlewares = (position) => {\n    if (!position) {\n      this.before = []\n      this.after = []\n    } else {\n      this[position] = []\n    }\n  }\n  */\n  dynamicMiddlewares = (position) => {\n    return store => next => action => {\n      const middlewareAPI = {\n        getState: store.getState,\n        dispatch: (act) => store.dispatch(act),\n      }\n      const chain = this[position].map(middleware => middleware(middlewareAPI))\n      return compose(...chain)(next)(action)\n    }\n  }\n}\n", "// Integrations Reducer. Follows ducks pattern http://bit.ly/2DnERMc\nimport EVENTS from '../events'\n\nexport default function createReducer(getPlugins) {\n  return function plugins(state = {}, action) {\n    let newState = {}\n    if (action.type === 'initialize:aborted') {\n      return state\n    }\n    if (/^registerPlugin:([^:]*)$/.test(action.type)) {\n      const name = getNameFromEventType(action.type, 'registerPlugin')\n      const plugin = getPlugins()[name]\n      if (!plugin || !name) {\n        return state\n      }\n      const isEnabled = action.enabled\n      newState[name] = {\n        enabled: isEnabled,\n        /* if no initialization method. Set initialized true */\n        initialized: (isEnabled) ? Boolean(!plugin.initialize) : false,\n        /* If plugin enabled === false, set loaded to false, else check plugin.loaded function */\n        loaded: (isEnabled) ? Boolean(plugin.loaded()) : false,\n        config: plugin.config || {}\n      }\n      return { ...state, ...newState }\n    }\n    if (/^initialize:([^:]*)$/.test(action.type)) {\n      const name = getNameFromEventType(action.type, EVENTS.initialize)\n      const plugin = getPlugins()[name]\n      if (!plugin || !name) {\n        return state\n      }\n      newState[name] = {\n        ...state[name],\n        ...{\n          initialized: true,\n          /* check plugin.loaded function */\n          loaded: Boolean(plugin.loaded())\n        }\n      }\n      return { ...state, ...newState }\n    }\n    if (/^ready:([^:]*)$/.test(action.type)) {\n      // const name = getNameFromEventType(action.type, 'ready')\n      newState[action.name] = {\n        ...state[action.name],\n        ...{ loaded: true }\n      }\n      return { ...state, ...newState }\n    }\n    switch (action.type) {\n      /* case EVENTS.pluginFailed:\n        // console.log('PLUGIN_FAILED', action.name)\n        newState[action.name] = {\n          ...state[action.name],\n          ...{ loaded: false }\n        }\n        return { ...state, ...newState }\n      */\n      /* When analytics.plugins.disable called */\n      case EVENTS.disablePlugin:\n        return { \n          ...state,\n          ...togglePluginStatus(action.plugins, false, state)\n        }\n      /* When analytics.plugins.enable called */\n      case EVENTS.enablePlugin:\n        return {\n          ...state, \n          ...togglePluginStatus(action.plugins, true, state)\n        }\n      default:\n        return state\n    }\n  }\n}\n\nfunction getNameFromEventType(type, baseName) {\n  return type.substring(baseName.length + 1, type.length)\n}\n\nfunction togglePluginStatus(plugins, status, currentState) {\n  return plugins.reduce((acc, pluginKey) => {\n    acc[pluginKey] = {\n      ...currentState[pluginKey],\n      ...{\n        enabled: status \n      }\n    }\n    return acc\n  }, currentState)\n}\n", "export default function serialize(obj) {\n  try {\n   return JSON.parse(JSON.stringify(obj))\n  } catch (err) {}\n  return obj\n}", "// Track Module. Follows ducks pattern http://bit.ly/2DnERMc\nimport EVENTS from '../events'\nimport serialize from '../utils/serialize'\n\n// Track State\nconst initialState = {\n  last: {},\n  history: [],\n}\n\n// track reducer\nexport default function trackReducer(state = initialState, action) {\n  const { type, event, properties, options, meta } = action\n\n  switch (type) {\n    case EVENTS.track:\n      const trackEvent = serialize({\n        event,\n        properties,\n        ...(Object.keys(options).length) && { options: options },\n        meta\n      })\n      return {\n        ...state,\n        ...{\n          last: trackEvent,\n          // Todo prevent LARGE arrays https://bit.ly/2MnBwPT\n          history: state.history.concat(trackEvent)\n        }\n      }\n    default:\n      return state\n  }\n}\n", "import EVENTS from '../events'\n/*\nTODO figure out if this should live in state...\nQueue could be in mermory as well.\nBut also needs to be persisted to storage\n*/\n\nconst initialState = {\n  actions: [],\n}\n\nexport default function queueReducer(state = initialState, action) {\n  const { type, payload } = action\n\n  switch (type) {\n    case 'queue':\n      let actionChain\n      /* prioritize identify in event queue */\n      if (payload && payload.type && payload.type === EVENTS.identify) {\n        actionChain = [action].concat(state.actions)\n      } else {\n        actionChain = state.actions.concat(action)\n      }\n      return {\n        ...state,\n        actions: actionChain\n      }\n    case 'dequeue':\n      return []\n    // todo push events to history\n    default:\n      return state\n  }\n}\n\nexport const queueAction = (data, timestamp) => {\n  return {\n    type: 'queue',\n    timestamp: timestamp,\n    data: data\n  }\n}\n", "// Page View Reducer. Follows ducks pattern http://bit.ly/2DnERMc\nimport { isBrowser } from '@analytics/type-utils'\nimport serialize from '../utils/serialize'\n\nimport EVENTS from '../events'\n\nconst hashRegex = /#.*$/\n\nfunction canonicalUrl() {\n  if (!isBrowser) return\n  const tags = document.getElementsByTagName('link')\n  for (var i = 0, tag; tag = tags[i]; i++) {\n    if (tag.getAttribute('rel') === 'canonical') {\n      return tag.getAttribute('href')\n    }\n  }\n}\n\nfunction urlPath(url) {\n  const regex = /(http[s]?:\\/\\/)?([^\\/\\s]+\\/)(.*)/g\n  const matches = regex.exec(url)\n  const pathMatch = (matches && matches[3]) ? matches[3].split('?')[0].replace(hashRegex, '') : ''\n  return '/' + pathMatch\n}\n\n/**\n * Return the canonical URL and rmove the hash.\n * @param  {string} search - search param\n * @return {string} return current canonical URL\n */\nfunction currentUrl(search) {\n  const canonical = canonicalUrl()\n  if (!canonical) return window.location.href.replace(hashRegex, '')\n  return canonical.match(/\\?/) ? canonical : canonical + search\n}\n\n/**\n * Page data for overides\n * @typedef {object} PageData\n * @property {string} [title] - Page title\n * @property {string} [url] - Page url\n * @property {string} [path] - Page path\n * @property {string} [search] - Page search\n * @property {string} [width] - Page width\n * @property {string} [height] - Page height\n*/\n\n/**\n * Get information about current page\n * @typedef {Function} getPageData\n * @param  {PageData} [pageData = {}] - Page data overides\n * @return {PageData} resolved page data\n */\nexport const getPageData = (pageData = {}) => {\n  if (!isBrowser) return pageData\n  const { title, referrer } = document\n  const { location, innerWidth, innerHeight } = window\n  const { hash, search } = location\n  const url = currentUrl(search)\n  const page = {\n    title: title,\n    url: url,\n    path: urlPath(url),\n    hash: hash,\n    search: search,\n    width: innerWidth,\n    height: innerHeight,\n  }\n  if (referrer && referrer !== '') {\n    page.referrer = referrer\n  }\n\n  return {\n    ...page,\n    /* .page() user overrrides */\n    ...pageData\n  }\n}\n\nconst initialState = {\n  last: {},\n  history: [],\n}\n\n// page reducer\nexport default function page(state = initialState, action) {\n  const { properties, options, meta } = action\n  switch (action.type) {\n    case EVENTS.page:\n      const viewData = serialize({\n        properties,\n        meta,\n        ...(Object.keys(options).length) && { options: options },\n      })\n      return {\n        ...state,\n        ...{\n          last: viewData,\n          // Todo prevent LARGE arrays https://bit.ly/2MnBwPT\n          history: state.history.concat(viewData)\n        }\n      }\n    default:\n      return state\n  }\n}\n", "// Context Reducer.  Follows ducks pattern http://bit.ly/2DnERMc\nimport { getBrowserLocale, getTimeZone, uuid } from 'analytics-utils'\nimport { isBrowser } from '@analytics/type-utils'\nimport EVENTS from '../events'\nimport { LIB_NAME } from '../utils/internalConstants'\nimport getOSNameNode from '../utils/getOSName/node'\nimport getOSNameBrowser from '../utils/getOSName/browser'\n\nlet osName\nlet referrer\nlet locale\nlet timeZone\nif (BROWSER) {\n  osName = getOSNameBrowser()\n  referrer = (isBrowser) ? document.referrer : null\n  locale = getBrowserLocale()\n  timeZone = getTimeZone()\n} else {\n  osName = getOSNameNode()\n  referrer = {}\n}\n\nconst initialState = {\n  initialized: false,\n  sessionId: uuid(),\n  app: null,\n  version: null,\n  debug: false,\n  offline: (isBrowser) ? !navigator.onLine : false, // use node network is-online\n  os: {\n    name: osName,\n  },\n  userAgent: (isBrowser) ? navigator.userAgent : 'node', // https://github.com/bestiejs/platform.js\n  library: {\n    name: LIB_NAME,\n    // TODO fix version number. npm run publish:patch has wrong version\n    version: VERSION\n  },\n  timezone: timeZone,\n  locale: locale,\n  campaign: {},\n  referrer: referrer,\n}\n\n// context reducer\nexport default function context(state = initialState, action) {\n  const { initialized } = state\n  const { type, campaign } = action\n  switch (type) {\n    case EVENTS.campaign:\n      return {\n        ...state,\n        ...{ campaign: campaign }\n      }\n    case EVENTS.offline:\n      return {\n        ...state,\n        ...{ offline: true }\n      }\n    case EVENTS.online:\n      return {\n        ...state,\n        ...{ offline: false }\n      }\n    default:\n      if (!initialized) {\n        return {\n          ...initialState,\n          ...state,\n          ...{ initialized: true }\n        }\n      }\n      return state\n  }\n}\n\nconst excludeItems = ['plugins', 'reducers', 'storage']\n// Pull plugins and reducers off intital config\nexport function makeContext(config) {\n  return Object.keys(config).reduce((acc, current) => {\n    if (excludeItems.includes(current)) {\n      return acc\n    }\n    acc[current] = config[current]\n    return acc\n  }, {})\n}\n", "import { isBrowser } from '@analytics/type-utils'\n\nexport default function getBrowserOS() {\n  if (!isBrowser) return false\n  const os = navigator.appVersion\n  // ~os bitwise operator to check if in navigator\n  if (~os.indexOf('Win')) return 'Windows'\n  if (~os.indexOf('Mac')) return 'MacOS'\n  if (~os.indexOf('X11')) return 'UNIX'\n  if (~os.indexOf('Linux')) return 'Linux'\n  // default\n  return 'Unknown OS'\n}\n", "import { isBrowser } from '@analytics/type-utils'\n\nfunction listen(events, func, toAdd) {\n  if (!isBrowser) return\n  const fn = window[(toAdd ? 'add' : 'remove') + 'EventListener']\n  events.split(' ').forEach(ev => {\n    fn(ev, func)\n  })\n}\n\nexport function check() {\n  return Promise.resolve(!navigator.onLine)\n}\n\nexport function watch(cb) {\n  const fn = _ => check().then(cb)\n  const listener = listen.bind(null, 'online offline', fn)\n  listener(true)\n  // return unsubscribe function\n  return _ => listener(false)\n}\n", "import { set, globalContext, KEY } from '@analytics/global-storage-utils'\nimport { compose } from '../vendor/redux'\nimport { LIB_NAME } from './internalConstants'\n\nexport function Debug() {\n  // Global key is window.__global__.analytics\n  set(LIB_NAME, [])\n  // Return debugger\n  return (createStore) => {\n    return (reducer, preloadedState, enhancer) => {\n      const store = createStore(reducer, preloadedState, enhancer)\n      const origDispatch = store.dispatch\n      const dispatch = (action) => {\n        const a = action.action || action\n        globalContext[KEY][LIB_NAME].push(a)\n        return origDispatch(action)\n      }\n      return Object.assign(store, { dispatch: dispatch })\n    }\n  }\n}\n\nexport function composeWithDebug(config) {\n  return function () {\n    return compose(compose.apply(null, arguments), Debug(config))\n  }\n}\n", "import { isArray } from '@analytics/type-utils'\n\nexport default function ensureArray(singleOrArray) {\n  if (!singleOrArray) return []\n  if (isArray(singleOrArray)) return singleOrArray\n  return [singleOrArray] \n}", "import getCallback from './getCallback'\nimport { stack } from './callback-stack'\nimport timestamp from './timestamp'\nimport { uuid } from 'analytics-utils'\n\n// Async promise resolver\nfunction deferredPromiseResolver(resolver, callback) {\n  return (data) => {\n    if (callback) callback(data)\n    resolver(data)\n  }\n}\n\nexport default function generateMeta(meta = {}, resolve, possibleCallbacks) {\n    const rid = uuid()\n    if (resolve) {\n      // stack[`${rid}-info`] = meta\n      stack[rid] = deferredPromiseResolver(resolve, getCallback(possibleCallbacks))\n    }\n    return {\n      ...meta,\n      rid: rid,\n      ts: timestamp(),\n      ...(!resolve) ? {} : { hasCallback: true },\n    }\n  }", "import { isFunction } from '@analytics/type-utils'\n\n/**\n * Grab first function found from arguments\n * @param {array} [argArray] - arguments array to find first function\n * @returns {Function|undefined}\n */\nexport default function getCallbackFromArgs(argArray) {\n  const args = argArray || Array.prototype.slice.call(arguments)\n  let cb\n  for (let i = 0; i < args.length; i++) {\n    if (isFunction(args[i])) {\n      cb = args[i]; break;\n    }\n  }\n  return cb\n}", "\nexport default function timeStamp() {\n  return new Date().getTime()\n}\n", "import { uuid, paramsParse, dotProp } from 'analytics-utils'\nimport { get, set, remove } from '@analytics/global-storage-utils'\nimport { isBrowser, isFunction, isObject, isString } from '@analytics/type-utils'\nimport { createStore, combineReducers, applyMiddleware, compose } from './vendor/redux'\nimport * as CONSTANTS from './constants'\nimport { ID, ANONID, ERROR_URL } from './utils/internalConstants'\nimport EVENTS, { coreEvents, nonEvents, isReservedAction } from './events'\n// Middleware\nimport * as middleware from './middleware'\nimport DynamicMiddleware from './middleware/dynamic'\n// Modules\nimport pluginsMiddleware from './modules/plugins'\nimport track from './modules/track'\nimport queue from './modules/queue'\nimport page, { getPageData } from './modules/page'\nimport context, { makeContext } from './modules/context'\nimport user, { getUserPropFunc, tempKey, getPersistedUserData } from './modules/user'\n/* Utils */\nimport { watch } from './utils/handleNetworkEvents'\nimport { Debug, composeWithDebug } from './utils/debug'\nimport heartBeat from './utils/heartbeat'\nimport ensureArray from './utils/ensureArray'\nimport enrichMeta from './utils/enrichMeta'\nimport './pluginTypeDef'\n\n/**\n * Analytics library configuration\n *\n * After the library is initialized with config, the core API is exposed & ready for use in the application.\n *\n * @param {object} config - analytics core config\n * @param {string} [config.app] - Name of site / app\n * @param {string} [config.version] - Version of your app\n * @param {boolean} [config.debug] - Should analytics run in debug mode\n * @param {Array.<AnalyticsPlugin>}  [config.plugins] - Array of analytics plugins\n * @return {AnalyticsInstance} Analytics Instance\n * @example\n *\n * import Analytics from 'analytics'\n * import pluginABC from 'analytics-plugin-abc'\n * import pluginXYZ from 'analytics-plugin-xyz'\n *\n * // initialize analytics\n * const analytics = Analytics({\n *   app: 'my-awesome-app',\n *   plugins: [\n *     pluginABC,\n *     pluginXYZ\n *   ]\n * })\n *\n */\nfunction analytics(config = {}) {\n  const customReducers = config.reducers || {}\n  const initialUser = config.initialUser || {}\n  // @TODO add custom value reolvers for userId and anonId\n  // const resolvers = config.resolvers || {}\n  // if (BROWSER) {\n  //   console.log('INIT browser')\n  // }\n\n  // if (SERVER) {\n  //   console.log('INIT SERVER')\n  // }\n  \n  /* Parse plugins array */\n  const parsedOptions = (config.plugins || []).reduce((acc, plugin) => {\n    if (isFunction(plugin)) {\n      /* Custom redux middleware */\n      acc.middlewares = acc.middlewares.concat(plugin)\n      return acc\n    }\n    // Legacy plugin with name\n    if (plugin.NAMESPACE) plugin.name = plugin.NAMESPACE\n    if (!plugin.name) {\n      /* Plugins must supply a \"name\" property. See error url for more details */\n      throw new Error(ERROR_URL + '1')\n    }\n    // if plugin exposes EVENTS capture available events\n    const definedEvents = (plugin.EVENTS) ? Object.keys(plugin.EVENTS).map((k) => {\n      return plugin.EVENTS[k]\n    }) : []\n\n    const enabledFromMerge = !(plugin.enabled === false)\n    const enabledFromPluginConfig = !(plugin.config && plugin.config.enabled === false)\n    // top level { enabled: false } takes presidence over { config: enabled: false }\n    acc.pluginEnabled[plugin.name] = enabledFromMerge && enabledFromPluginConfig\n    delete plugin.enabled\n\n    if (plugin.methods) {\n      acc.methods[plugin.name] = Object.keys(plugin.methods).reduce((a, c) => {\n        // enrich methods with analytics instance\n        a[c] = appendArguments(plugin.methods[c])\n        return a\n      }, {})\n      // Remove additional methods from plugins\n      delete plugin.methods\n    }\n    // Convert available methods into events\n    const methodsToEvents = Object.keys(plugin)\n    // Combine events\n    const allEvents = methodsToEvents.concat(definedEvents)\n    // Dedupe events list\n    const allEventsUnique = new Set(acc.events.concat(allEvents))\n    acc.events = Array.from(allEventsUnique)\n\n    acc.pluginsArray = acc.pluginsArray.concat(plugin)\n\n    if (acc.plugins[plugin.name]) {\n      throw new Error(plugin.name + 'AlreadyLoaded')\n    }\n    acc.plugins[plugin.name] = plugin\n    if (!acc.plugins[plugin.name].loaded) {\n      // set default loaded func\n      acc.plugins[plugin.name].loaded = () => true\n    }\n    return acc\n  }, {\n    plugins: {},\n    pluginEnabled: {},\n    methods: {},\n    pluginsArray: [],\n    middlewares: [],\n    events: []\n  })\n  \n  /* Storage by default is set to global & is not persisted */\n  const storage = (config.storage) ? config.storage : {\n    getItem: get,\n    setItem: set,\n    removeItem: remove\n  }\n\n  const getUserProp = getUserPropFunc(storage)\n\n  // mutable intregrations object for dynamic loading\n  let customPlugins = parsedOptions.plugins\n\n  /* Grab all registered events from plugins loaded */\n  const allPluginEvents = parsedOptions.events.filter((name) => {\n    return !nonEvents.includes(name)\n  }).sort()\n  const uniqueEvents = new Set(allPluginEvents.concat(coreEvents).filter((name) => {\n    return !nonEvents.includes(name)\n  }))\n  const allSystemEvents = Array.from(uniqueEvents).sort()\n\n  /* plugin methods(functions) must be kept out of state. thus they live here */\n  const getPlugins = () => customPlugins\n\n  const {\n    addMiddleware,\n    removeMiddleware,\n    dynamicMiddlewares\n  } = new DynamicMiddleware()\n\n  const nonAbortable = () => {\n    // throw new Error(`${ERROR_URL}3`)\n    throw new Error('Abort disabled inListener')\n  }\n\n  // Parse URL parameters\n  const params = paramsParse()\n  // Initialize visitor information\n  const persistedUser = getPersistedUserData(storage)\n  const visitorInfo = {\n    ...persistedUser,\n    ...initialUser,\n    ...(!params.an_uid) ? {} : { userId: params.an_uid },\n    ...(!params.an_aid) ? {} : { anonymousId: params.an_aid },\n  }\n  // If no anon id set, create one\n  if (!visitorInfo.anonymousId) {\n    visitorInfo.anonymousId = uuid()\n  }\n\n  /**\n   * Async Management methods for plugins. \n   * \n   * This is also where [custom methods](https://bit.ly/329vFXy) are loaded into the instance.\n   * @typedef {Object} Plugins\n   * @property {EnablePlugin} enable - Set storage value\n   * @property {DisablePlugin} disable - Remove storage value\n   * @example\n   *\n   * // Enable a plugin by namespace\n   * analytics.plugins.enable('keenio')\n   *\n   * // Disable a plugin by namespace\n   * analytics.plugins.disable('google-analytics')\n   */\n  const plugins = {\n    /**\n     * Enable analytics plugin\n     * @typedef {Function} EnablePlugin\n     * @param  {string|string[]} plugins - name of plugins(s) to disable\n     * @param  {Function} [callback] - callback after enable runs\n     * @returns {Promise}\n     * @example\n     *\n     * analytics.plugins.enable('google-analytics').then(() => {\n     *   console.log('do stuff')\n     * })\n     *\n     * // Enable multiple plugins at once\n     * analytics.plugins.enable(['google-analytics', 'segment']).then(() => {\n     *   console.log('do stuff')\n     * })\n     */\n    enable: (plugins, callback) => {\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.enablePlugin,\n          plugins: ensureArray(plugins),\n          _: { originalAction: EVENTS.enablePlugin },\n        }, resolve, [ callback ])\n      })\n    },\n    /**\n     * Disable analytics plugin\n     * @typedef {Function} DisablePlugin\n     * @param  {string|string[]} plugins - name of integration(s) to disable\n     * @param  {Function} callback - callback after disable runs\n     * @returns {Promise}\n     * @example\n     *\n     * analytics.plugins.disable('google').then(() => {\n     *   console.log('do stuff')\n     * })\n     *\n     * analytics.plugins.disable(['google', 'segment']).then(() => {\n     *   console.log('do stuff')\n     * })\n     */\n    disable: (plugins, callback) => {\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.disablePlugin,\n          plugins: ensureArray(plugins),\n          _: { originalAction: EVENTS.disablePlugin },\n        }, resolve, [callback])\n      })\n    },\n    /*\n     * Load registered analytic providers.\n     * @param  {String} plugins - integration namespace\n     *\n     * @example\n     * analytics.plugins.load('segment')\n     @TODO implement\n    load: (plugins) => {\n      store.dispatch({\n        type: EVENTS.loadPlugin,\n        // Todo handle multiple plugins via array\n        plugins: (plugins) ? [plugins] : Object.keys(getPlugins()),\n      })\n    },\n    */\n    /* @TODO if it stays, state loaded needs to be set. Re PLUGIN_INIT above\n    add: (newPlugin) => {\n      if (typeof newPlugin !== 'object') return false\n      // Set on global integration object\n      customPlugins = Object.assign({}, customPlugins, {\n        [`${newPlugin.name}`]: newPlugin\n      })\n      // then add it, and init state key\n      store.dispatch({\n        type: EVENTS.pluginRegister,\n        name: newPlugin.name,\n        plugin: newPlugin\n      })\n    }, */\n    // Merge in custom plugin methods\n    ...parsedOptions.methods\n  }\n  \n  /**\n   * Analytic instance returned from initialization\n   * @typedef {Object} AnalyticsInstance\n   * @property {Identify} identify - Identify a user\n   * @property {Track} track - Track an analytics event\n   * @property {Page} page - Trigger page view\n   * @property {User} user - Get user data\n   * @property {Reset} reset - Clear information about user & reset analytics\n   * @property {Ready} ready - Fire callback on analytics ready event\n   * @property {On} on - Fire callback on analytics lifecycle events.\n   * @property {Once} once - Fire callback on analytics lifecycle events once.\n   * @property {GetState} getState - Get data about user, activity, or context.\n   * @property {Storage} storage - storage methods\n   * @property {Plugins} plugins - plugin methods\n   */\n  const instance = {\n    /**\n    * Identify a user. This will trigger `identify` calls in any installed plugins and will set user data in localStorage\n    * @typedef {Function} Identify\n    * @param  {String}   userId  - Unique ID of user\n    * @param  {Object}   [traits]  - Object of user traits\n    * @param  {Object}   [options] - Options to pass to identify call\n    * @param  {Function} [callback] - Callback function after identify completes\n    * @returns {Promise}\n    * @api public\n    *\n    * @example\n    *\n    * // Basic user id identify\n    * analytics.identify('xyz-123')\n    *\n    * // Identify with additional traits\n    * analytics.identify('xyz-123', {\n    *   name: 'steve',\n    *   company: 'hello-clicky'\n    * })\n    *\n    * // Fire callback with 2nd or 3rd argument\n    * analytics.identify('xyz-123', () => {\n    *   console.log('do this after identify')\n    * })\n    *\n    * // Disable sending user data to specific analytic tools\n    * analytics.identify('xyz-123', {}, {\n    *   plugins: {\n    *     // disable sending this identify call to segment\n    *     segment: false\n    *   }\n    * })\n    *\n    * // Send user data to only to specific analytic tools\n    * analytics.identify('xyz-123', {}, {\n    *   plugins: {\n    *     // disable this specific identify in all plugins except customerio\n    *     all: false,\n    *     customerio: true\n    *   }\n    * })\n    */\n    identify: async (userId, traits, options, callback) => {\n      const id = isString(userId) ? userId : null\n      const data = isObject(userId) ? userId : traits\n      const opts = options || {}\n      const user = instance.user()\n\n      /* sets temporary in memory id. Not to be relied on */\n      set(tempKey(ID), id)\n\n      const resolvedId = id || data.userId || getUserProp(ID, instance, data)\n\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.identifyStart,\n          userId: resolvedId,\n          traits: data || {},\n          options: opts,\n          anonymousId: user.anonymousId,\n          // Add previousId if exists\n          ...(user.id && (user.id !== id) && { previousId: user.id }),\n        }, resolve, [traits, options, callback])\n      })\n    },\n    /**\n     * Track an analytics event. This will trigger `track` calls in any installed plugins\n     * @typedef {Function} Track\n     * @param  {String}   eventName - Event name\n     * @param  {Object}   [payload]   - Event payload\n     * @param  {Object}   [options]   - Event options\n     * @param  {Function} [callback]  - Callback to fire after tracking completes\n     * @returns {Promise}\n     * @api public\n     *\n     * @example\n     *\n     * // Basic event tracking\n     * analytics.track('buttonClicked')\n     *\n     * // Event tracking with payload\n     * analytics.track('itemPurchased', {\n     *   price: 11,\n     *   sku: '1234'\n     * })\n     *\n     * // Fire callback with 2nd or 3rd argument\n     * analytics.track('newsletterSubscribed', () => {\n     *   console.log('do this after track')\n     * })\n     *\n     * // Disable sending this event to specific analytic tools\n     * analytics.track('cartAbandoned', {\n     *   items: ['xyz', 'abc']\n     * }, {\n     *   plugins: {\n     *     // disable track event for segment\n     *     segment: false\n     *   }\n     * })\n     *\n     * // Send event to only to specific analytic tools\n     * analytics.track('customerIoOnlyEventExample', {\n     *   price: 11,\n     *   sku: '1234'\n     * }, {\n     *   plugins: {\n     *     // disable this specific track call all plugins except customerio\n     *     all: false,\n     *     customerio: true\n     *   }\n     * })\n     */\n    track: async (eventName, payload, options, callback) => {\n      const name = isObject(eventName) ? eventName.event : eventName\n      if (!name || !isString(name)) {\n        throw new Error('EventMissing')\n      }\n      const data = isObject(eventName) ? eventName : (payload || {})\n      const opts = isObject(options) ? options : {}\n\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.trackStart,\n          event: name,\n          properties: data,\n          options: opts,\n          userId: getUserProp(ID, instance, payload),\n          anonymousId: getUserProp(ANONID, instance, payload),\n        }, resolve, [payload, options, callback])\n      })\n    },\n    /**\n     * Trigger page view. This will trigger `page` calls in any installed plugins\n     * @typedef {Function} Page\n     * @param  {PageData} [data] - Page data overrides.\n     * @param  {Object}   [options] - Page tracking options\n     * @param  {Function} [callback] - Callback to fire after page view call completes\n     * @returns {Promise}\n     * @api public\n     *\n     * @example\n     *\n     * // Basic page tracking\n     * analytics.page()\n     *\n     * // Page tracking with page data overrides\n     * analytics.page({\n     *   url: 'https://google.com'\n     * })\n     *\n     * // Fire callback with 1st, 2nd or 3rd argument\n     * analytics.page(() => {\n     *   console.log('do this after page')\n     * })\n     *\n     * // Disable sending this pageview to specific analytic tools\n     * analytics.page({}, {\n     *   plugins: {\n     *     // disable page tracking event for segment\n     *     segment: false\n     *   }\n     * })\n     *\n     * // Send pageview to only to specific analytic tools\n     * analytics.page({}, {\n     *   plugins: {\n     *     // disable this specific page in all plugins except customerio\n     *     all: false,\n     *     customerio: true\n     *   }\n     * })\n     */\n    page: async (data, options, callback) => {\n      const d = isObject(data) ? data : {}\n      const opts = isObject(options) ? options : {}\n\n      /*\n      // @TODO add custom value reolvers for userId and anonId\n      if (resolvers.getUserId) {\n        const asyncUserId = await resolvers.getUserId()\n        console.log('x', x)\n      }\n      */\n\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.pageStart,\n          properties: getPageData(d),\n          options: opts,\n          userId: getUserProp(ID, instance, d),\n          anonymousId: getUserProp(ANONID, instance, d),\n        }, resolve, [data, options, callback])\n      })\n    },\n    /**\n     * Get user data\n     * @typedef {Function} User\n     * @param {string} [key] - dot.prop.path of user data. Example: 'traits.company.name'\n     * @returns {string|object} value of user data or null\n     *\n     * @example\n     *\n     * // Get all user data\n     * const userData = analytics.user()\n     *\n     * // Get user id\n     * const userId = analytics.user('userId')\n     *\n     * // Get user company name\n     * const companyName = analytics.user('traits.company.name')\n     */\n    user: (key) => {\n      if (key === ID || key === 'id') {\n        return getUserProp(ID, instance)\n      }\n      if (key === ANONID || key === 'anonId') {\n        return getUserProp(ANONID, instance)\n      }\n      const user = instance.getState('user')\n      if (!key) return user\n      return dotProp(user, key)\n    },\n    /**\n     * Clear all information about the visitor & reset analytic state.\n     * @typedef {Function} Reset\n     * @param {Function} [callback] - Handler to run after reset\n     * @returns {Promise}\n     * @example\n     *\n     * // Reset current visitor\n     * analytics.reset()\n     */\n    reset: (callback) => {\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.resetStart\n        }, resolve, callback)\n      })\n    },\n    /**\n     * Fire callback on analytics ready event\n     * @typedef {Function} Ready\n     * @param  {Function} callback - function to trigger when all providers have loaded\n     * @returns {DetachListeners} - Function to detach listener\n     *\n     * @example\n     *\n     * analytics.ready((payload) => {\n     *   console.log('all plugins have loaded or were skipped', payload);\n     * })\n     */\n    ready: (callback) => {\n      return instance.on(EVENTS.ready, callback)\n    },\n    /**\n     * Attach an event handler function for analytics lifecycle events.\n     * @typedef {Function} On\n     * @param  {String}   name - Name of event to listen to\n     * @param  {Function} callback - function to fire on event\n     * @return {DetachListeners} - Function to detach listener\n     *\n     * @example\n     *\n     * // Fire function when 'track' calls happen\n     * analytics.on('track', ({ payload }) => {\n     *   console.log('track call just happened. Do stuff')\n     * })\n     *\n     * // Remove listener before it is called\n     * const removeListener = analytics.on('track', ({ payload }) => {\n     *   console.log('This will never get called')\n     * })\n     *\n     * // cleanup .on listener\n     * removeListener()\n     */\n    on: (name, callback) => {\n      if (!name || !isFunction(callback)) {\n        return false\n      }\n      if (name === EVENTS.bootstrap) {\n        throw new Error('.on disabled for ' + name)\n      }\n      const startRegex = /Start$|Start:/\n      if (name === '*') {\n        const beforeHandler = store => next => action => {\n          if (action.type.match(startRegex)) {\n            callback({ // eslint-disable-line\n              payload: action,\n              instance,\n              plugins: customPlugins\n            })\n          }\n          return next(action)\n        }\n        const afterHandler = store => next => action => {\n          if (!action.type.match(startRegex)) {\n            callback({ // eslint-disable-line\n              payload: action,\n              instance,\n              plugins: customPlugins\n            })\n          }\n          return next(action)\n        }\n        addMiddleware(beforeHandler, before)\n        addMiddleware(afterHandler, after)\n        /**\n         * Detach listeners\n         * @typedef {Function} DetachListeners\n         */\n        return () => {\n          removeMiddleware(beforeHandler, before)\n          removeMiddleware(afterHandler, after)\n        }\n      }\n\n      const position = (name.match(startRegex)) ? before : after // eslint-disable-line\n      const handler = store => next => action => {\n        // Subscribe to EVERYTHING\n        if (action.type === name) {\n          callback({ // eslint-disable-line\n            payload: action,\n            instance: instance,\n            plugins: customPlugins,\n            abort: nonAbortable\n          })\n        }\n        /* For future matching of event subpaths `track:*` etc\n        } else if (name.match(/\\*$/)) {\n          const match = (name === '*') ? '.' : name\n          const regex = new RegExp(`${match}`, 'g')\n        } */\n        return next(action)\n      }\n      addMiddleware(handler, position)\n      return () => removeMiddleware(handler, position)\n    },\n    /**\n     * Attach a handler function to an event and only trigger it only once.\n     * @typedef {Function} Once\n     * @param  {String} name - Name of event to listen to\n     * @param  {Function} callback - function to fire on event\n     * @return {DetachListeners} - Function to detach listener\n     *\n     * @example\n     *\n     * // Fire function only once 'track'\n     * analytics.once('track', ({ payload }) => {\n     *   console.log('This will only triggered once when analytics.track() fires')\n     * })\n     *\n     * // Remove listener before it is called\n     * const listener = analytics.once('track', ({ payload }) => {\n     *   console.log('This will never get called b/c listener() is called')\n     * })\n     *\n     * // cleanup .once listener before it fires\n     * listener()\n     */\n    once: (name, callback) => {\n      if (!name || !isFunction(callback)) {\n        return false\n      }\n      if (name === EVENTS.bootstrap) {\n        throw new Error('.once disabled for ' + name)\n      }\n      const detachListener = instance.on(name, ({ payload }) => {\n        callback({ // eslint-disable-line\n          payload: payload,\n          instance: instance,\n          plugins: customPlugins,\n          abort: nonAbortable\n        })\n        // detach listener after its called once\n        detachListener()\n      })\n      return detachListener\n    },\n    /**\n     * Get data about user, activity, or context. Access sub-keys of state with `dot.prop` syntax.\n     * @typedef {Function} GetState\n     * @param  {string} [key] - dot.prop.path value of state\n     * @return {any}\n     *\n     * @example\n     *\n     * // Get the current state of analytics\n     * analytics.getState()\n     *\n     * // Get a subpath of state\n     * analytics.getState('context.offline')\n     */\n    getState: (key) => {\n      const state = store.getState()\n      if (key) return dotProp(state, key)\n      return Object.assign({}, state)\n    },\n    /*\n     * Emit events for other plugins or middleware to react to.\n     * @param  {Object} action - event to dispatch\n     */\n    dispatch: (action) => {\n      const actionData = isString(action) ? { type: action } : action\n      if (isReservedAction(actionData.type)) {\n        throw new Error('reserved action ' + actionData.type)\n      }\n      const _private = action._ || {}\n      // Dispatch actionStart\n      // const autoPrefixType = `${actionData.type.replace(/Start$/, '')}Start`\n\n      const dispatchData = {\n        ...actionData,\n        _: {\n          originalAction: actionData.type,\n          ..._private\n        }\n        // type: `${autoPrefixType}`\n      }\n      store.dispatch(dispatchData)\n    },\n    // Do not use. Will be removed. Here for Backwards compatiblity.\n    // Moved to analytics.plugins.enable\n    enablePlugin: plugins.enable,\n    /// Do not use. Will be removed. Here for Backwards compatiblity.\n    /// Moved to analytics.plugins.disable\n    disablePlugin: plugins.disable,\n    // Do not use. Will be removed. Here for Backwards compatiblity.\n    // New plugins api\n    plugins: plugins,\n    /**\n     * Storage utilities for persisting data.\n     * These methods will allow you to save data in localStorage, cookies, or to the window.\n     * @typedef {Object} Storage\n     * @property {GetItem} getItem - Get value from storage\n     * @property {SetItem} setItem - Set storage value\n     * @property {RemoveItem} removeItem - Remove storage value\n     *\n     * @example\n     *\n     * // Pull storage off analytics instance\n     * const { storage } = analytics\n     *\n     * // Get value\n     * storage.getItem('storage_key')\n     *\n     * // Set value\n     * storage.setItem('storage_key', 'value')\n     *\n     * // Remove value\n     * storage.removeItem('storage_key')\n     */\n    storage: {\n      /**\n       * Get value from storage\n       * @typedef {Function} GetItem\n       * @param {String} key - storage key\n       * @param {Object} [options] - storage options\n       * @return {Any}\n       *\n       * @example\n       *\n       * analytics.storage.getItem('storage_key')\n       */\n      getItem: storage.getItem,\n      /**\n       * Set storage value\n       * @typedef {Function} SetItem\n       * @param {String} key - storage key\n       * @param {any} value - storage value\n       * @param {Object} [options] - storage options\n       *\n       * @example\n       *\n       * analytics.storage.setItem('storage_key', 'value')\n       */\n      setItem: (key, value, options) => {\n        store.dispatch({\n          type: EVENTS.setItemStart,\n          key: key,\n          value: value,\n          options: options\n        })\n      },\n      /**\n       * Remove storage value\n       * @typedef {Function} RemoveItem\n       * @param {String} key - storage key\n       * @param {Object} [options] - storage options\n       *\n       * @example\n       *\n       * analytics.storage.removeItem('storage_key')\n       */\n      removeItem: (key, options) => {\n        store.dispatch({\n          type: EVENTS.removeItemStart,\n          key: key,\n          options: options\n        })\n      },\n    },\n    /*\n     * Set the anonymous ID of the visitor\n     * @param {String} anonymousId - anonymous Id to set\n     * @param {Object} [options] - storage options\n     *\n     * @example\n     *\n     * // Set anonymous ID\n     * analytics.setAnonymousId('1234567')\n     */\n    setAnonymousId: (anonymousId, options) => {\n      /* sets temporary in memory id. Not to be relied on */\n      // set(tempKey(ANONID), anonymousId)\n      instance.storage.setItem(CONSTANTS.ANON_ID, anonymousId, options)\n    },\n    /*\n     * Events exposed by core analytics library and all loaded plugins\n     * @type {Array}\n     */\n    events: {\n      core: coreEvents,\n      plugins: allPluginEvents,\n      // byType: (type) => {} @Todo grab logic from engine and give inspectable events\n    }\n  }\n  const enrichMiddleware = storeAPI => next => action => {\n    if (!action.meta) {\n      action.meta = enrichMeta()\n    }\n    return next(action)\n  }\n  const middlewares = parsedOptions.middlewares.concat([\n    enrichMiddleware,\n    /* Core analytics middleware */\n    dynamicMiddlewares(before), // Before dynamic middleware <-- fixed pageStart .on listener\n    /* Plugin engine */\n    middleware.plugins(instance, getPlugins, {\n      all: allSystemEvents,\n      plugins: allPluginEvents\n    }),\n    middleware.storage(storage),\n    middleware.initialize(instance),\n    middleware.identify(instance, storage),\n    /* after dynamic middleware */\n    dynamicMiddlewares(after)\n  ])\n\n  /* Initial analytics state keys */\n  const coreReducers = {\n    context: context,\n    user: user(storage),\n    page: page,\n    track: track,\n    plugins: pluginsMiddleware(getPlugins),\n    queue: queue\n  }\n\n  let composeEnhancers = compose\n  let composeWithGlobalDebug = compose\n  if (isBrowser && config.debug) {\n    const devTools = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n    if (devTools) {\n      composeEnhancers = devTools({ trace: true, traceLimit: 25 })\n    }\n    composeWithGlobalDebug = function() {\n      if (arguments.length === 0) return Debug()\n      if (isObject(typeof arguments[0])) return composeWithDebug(arguments[0])\n      return composeWithDebug().apply(null, arguments)\n    }\n  }\n\n  const initialConfig = makeContext(config)\n\n  const intialPluginState = parsedOptions.pluginsArray.reduce((acc, plugin) => {\n    const { name, config, loaded } = plugin\n    const isEnabled = parsedOptions.pluginEnabled[name]\n    acc[name] = {\n      enabled: isEnabled,\n      // If plugin enabled & has no initialize method, set initialized to true, else false\n      initialized: (isEnabled) ? Boolean(!plugin.initialize) : false,\n      loaded: Boolean(loaded()),\n      config: config || {}\n    }\n    return acc\n  }, {})\n  \n  const initialState = {\n    context: initialConfig,\n    user: visitorInfo,\n    plugins: intialPluginState,\n    // Todo allow for more userland defined initial state?\n  }\n\n  /* Create analytics store! */\n  const store = createStore(\n    // register reducers\n    combineReducers({ ...coreReducers, ...customReducers }),\n    // set user defined initial state\n    initialState,\n    // register middleware & plugins used\n    composeWithGlobalDebug(\n      composeEnhancers(\n        applyMiddleware(...middlewares),\n      )\n    )\n  )\n\n  /* Supe up dispatch with callback promise resolver. Happens in enrichMeta */\n  function enhanceDispatch(fn) {\n    return function (event, resolver, callbacks) {\n      // console.log('original event', event)\n      const meta = enrichMeta(event.meta, resolver, ensureArray(callbacks))\n      // if (resolver) console.log('dispatch resolver', resolver)\n      // if (callbacks) console.log('dispatch callbacks', callbacks)\n      const newEvent = { ...event, ...{ meta: meta } }\n      // console.log('newEvent', newEvent)\n      return fn.apply(null, [ newEvent ])\n    }\n  }\n\n  // Automatically apply meta to dispatch calls\n  store.dispatch = enhanceDispatch(store.dispatch)\n\n  /* Synchronously call bootstrap & register Plugin methods */\n  const pluginKeys = Object.keys(customPlugins)\n\n  /* Bootstrap analytic plugins */\n  store.dispatch({\n    type: EVENTS.bootstrap,\n    plugins: pluginKeys,\n    config: initialConfig,\n    params: params,\n    user: visitorInfo,\n    initialUser,\n    persistedUser\n  })\n\n  const enabledPlugins = pluginKeys.filter((name) => parsedOptions.pluginEnabled[name])\n  const disabledPlugins = pluginKeys.filter((name) => !parsedOptions.pluginEnabled[name])\n \n  /* Register analytic plugins */\n  store.dispatch({\n    type: EVENTS.registerPlugins,\n    plugins: pluginKeys,\n    enabled: parsedOptions.pluginEnabled,\n  })\n\n  /* dispatch register for individual plugins */\n  parsedOptions.pluginsArray.map((plugin, i) => {\n    const { bootstrap, config, name } = plugin\n    if (bootstrap && isFunction(bootstrap)) {\n      bootstrap({ instance, config, payload: plugin })\n    }\n    /* Register plugins */\n    store.dispatch({\n      type: EVENTS.registerPluginType(name),\n      name: name,\n      enabled: parsedOptions.pluginEnabled[name],\n      plugin: plugin\n    })\n\n    /* All plugins registered initialize, is last loop */\n    if (parsedOptions.pluginsArray.length === (i + 1)) {\n      store.dispatch({\n        type: EVENTS.initializeStart,\n        plugins: enabledPlugins,\n        disabled: disabledPlugins\n      })\n    }\n  })\n\n  if (BROWSER) {\n    /* Watch for network events */\n    watch((offline) => {\n      store.dispatch({\n        type: (offline) ? EVENTS.offline : EVENTS.online,\n      })\n    })\n    /* Tick heartbeat for queued events */\n    heartBeat(store, getPlugins, instance)\n  }\n\n  function appendArguments(fn) {\n    return function () {\n      /* Get original args */\n      const args = Array.prototype.slice.call(arguments)\n      /* Create clone of args */\n      let newArgs = new Array(fn.length)\n      for (let i = 0; i < args.length; i++) {\n        newArgs[i] = args[i]\n      }\n      /* Append new arg to end */\n      newArgs[newArgs.length] = instance\n      // Set instance on extended methods\n      return fn.apply({ instance }, newArgs)\n    }\n  }\n\n  /* Return analytics instance */\n  return instance\n}\n\n// Duplicated strings\nconst before = 'before'\nconst after = 'after'\n\nexport default analytics\n\n/*\n * analytics.init exported for standalone browser build\n * CDN build exposes global _analytics variable\n *\n * Initialize instance with _analytics.init() or _analytics['default']()\n */\nexport { analytics as init }\n\n/*\n * analytics.Analytics exported for node usage\n *\n * Initialize instance with _analytics.init() or _analytics['default']()\n */\nexport { analytics as Analytics }\n/*\n * Core Analytic events. These are exposed for third party plugins & listeners\n * Use these magic strings to attach functions to event names.\n * @type {Object}\n */\nexport { EVENTS }\n\nexport { CONSTANTS }\n", "import { get, set, remove } from '@analytics/global-storage-utils'\n\nexport const COOKIE = 'cookie'\n\nlet isSupported = hasCookies()\n\n/**\n * Get a cookie value\n * @param  {string} name - key of cookie\n * @return {string} value of cookie\n */\nexport const getCookie = cookie\n\n/**\n * Set a cookie value\n * @param {string} name  - key of cookie\n * @param {string} value - value of cookie\n * @param {string} days  - days to keep cookie\n */\nexport const setCookie = cookie\n\n/**\n * Remove a cookie value.\n * @param {string} name  - key of cookie\n */\nexport function removeCookie(name) {\n  return isSupported ? cookie(name, '', -1) : remove(name) \n}\n\n/**\n * Check if browser has cookie support\n * @returns {boolean}\n */\nexport function hasCookies() {\n  if (typeof isSupported !== 'undefined') {\n    return isSupported\n  }\n  const tmp = COOKIE + COOKIE\n  try {\n    // Try to set cookie\n    cookie(tmp, tmp)\n    isSupported = document.cookie.indexOf(tmp) !== -1\n    // Cleanup cookie\n    removeCookie(tmp)\n  } catch (e) {\n    isSupported = false\n  }\n  return isSupported\n}\n\n/** \n  * Cookie setter & getter\n  * @version    1.0.4\n  * @date       2015-03-13\n  * @stability  3 - Stable\n  * @author     Lauri Rooden <lauri@rooden.ee>\n  * @license    MIT License\n  * Modified by David Wells\n  * @param {string} name \n  * @param {*} value \n  * @param {*} ttl - Time to live in seconds\n  * @param {*} path - Cookie domain\n  * @param {*} domain - Cookie domain\n  * @param {Boolean} secure - secure cookie\n  * @returns {*} value\n  * @example\n    cookie('test', 'a') // set\n    cookie('test', 'a', 60*60*24, '/api', '*.example.com', true) // complex set - cookie(name, value, ttl, path, domain, secure)\n    cookie('test') // get\n    cookie('test', '', -1) // destroy\n*/\nfunction cookie(name, value, ttl, path, domain, secure) {\n  if (typeof window === 'undefined') return\n  const isSet = arguments.length > 1\n  /* If cookies not supported fallback to global */\n  if (isSupported === false) (isSet) ? set(name, value) : get(name)\n  /* Set values */\n  if (isSet) {\n    return document.cookie = name + '=' + encodeURIComponent(value) +\n      /* Set TTL set expiration on cookie */\n      ((!ttl) ? '' : '; expires=' + new Date(+new Date() + (ttl * 1000)).toUTCString() +\n      // If path set path\n      ((!path) ? '' : '; path=' + path) +\n      // If domain set domain\n      ((!domain) ? '' : '; domain=' + domain) +\n      // If secure set secure\n      ((!secure) ? '' : '; secure'))\n  }\n  /* Get values */\n  return decodeURIComponent((('; ' + document.cookie).split('; ' + name + '=')[1] || '').split(';')[0])\n}\n", "import { get, set, remove, hasSupport, wrap } from '@analytics/global-storage-utils'\n\nconst LOCAL_STORAGE = 'localStorage'\n\n/**\n * Check if browser has access to LocalStorage\n * @returns {Boolean}\n */\nconst hasLocalStorage = hasSupport.bind(null, LOCAL_STORAGE)\n\n/**\n * Get value from localStorage or fallback to global window\n * @param {string} key - Key of value to get\n * @returns {*} value\n */\nconst getItem = wrap(LOCAL_STORAGE, 'getItem', get)\n\n/**\n * Set value to localStorage or fallback to global window\n * @param {string} key - Key of value to set\n * @param {*} value \n * @returns value\n */\nconst setItem = wrap(LOCAL_STORAGE, 'setItem', set)\n\n/**\n * Remove value from localStorage or fallback to global window\n * @param {string} key - Key of value to remove\n */\nconst removeItem = wrap(LOCAL_STORAGE, 'removeItem', remove)\n\nexport {\n  LOCAL_STORAGE,\n  hasLocalStorage,\n  getItem,\n  setItem,\n  removeItem\n}", "import { get, set, remove, hasSupport, wrap } from '@analytics/global-storage-utils'\n\nconst SESSION_STORAGE = 'sessionStorage'\n\n/**\n * Check if browser has access to sessionStorage\n * @returns {Boolean}\n */\nconst hasSessionStorage = hasSupport.bind(null, SESSION_STORAGE)\n\n/**\n * Get value from sessionStorage or fallback to global window\n * @param {string} key - Key of value to get\n * @returns {*} value\n */\nconst getSessionItem = wrap(SESSION_STORAGE, 'getItem', get)\n\n/**\n * Set value to sessionStorage or fallback to global window\n * @param {string} key - Key of value to set\n * @param {*} value \n * @returns value\n */\nconst setSessionItem = wrap(SESSION_STORAGE, 'setItem', set)\n\n/**\n * Remove value from sessionStorage or fallback to global window\n * @param {string} key - Key of value to remove\n */\nconst removeSessionItem = wrap(SESSION_STORAGE, 'removeItem', remove)\n\nexport {\n  SESSION_STORAGE,\n  hasSessionStorage,\n  getSessionItem,\n  setSessionItem,\n  removeSessionItem\n}", "import { isObject } from '@analytics/type-utils'\n/**\n * Safe JSON parse\n * @param  {*} input - value to parse\n * @return {*} parsed input\n */\nexport default function parse(input) {\n  let value = input\n  try {\n    value = JSON.parse(input)\n    if (value === 'true') return true\n    if (value === 'false') return false\n    if (isObject(value)) return value\n    if (parseFloat(value) === value) {\n      value = parseFloat(value)\n    }\n  } catch (e) { }\n  if (value === null || value === \"\") {\n    return\n  }\n  return value\n}\n", "import { set, get, remove, globalContext, GLOBAL } from '@analytics/global-storage-utils'\nimport { getCookie, setCookie, removeCookie, hasCookies, COOKIE } from '@analytics/cookie-utils'\nimport { hasLocalStorage, LOCAL_STORAGE } from '@analytics/localstorage-utils'\nimport { hasSessionStorage, SESSION_STORAGE } from '@analytics/session-storage-utils'\nimport { isUndefined, isString, ANY, ALL } from '@analytics/type-utils'\nimport parse from './utils/parse'\n\n// Verify support\nconst hasStorage = hasLocalStorage()\nconst hasSessionSupport = hasSessionStorage()\nconst hasCookiesSupport = hasCookies()\n\n/**\n * Get storage item from localStorage, cookie, or window\n * @param  {string} key - key of item to get\n * @param  {object|string} [options] - storage options. If string location of where to get storage\n * @param  {string} [options.storage] - Define type of storage to pull from.\n * @return {Any}  the value of key\n */\nexport function getItem(key, options) {\n  if (!key) return\n  const type = getStorageType(options)\n  const getFirst = !useAll(type)\n\n  /* 1. Try localStorage */\n  const localValue = useLocal(type) ? parse(localStorage.getItem(key)) : undefined\n  if (getFirst && !isUndefined(localValue)) {\n    return localValue\n  }\n\n  /* 2. Fallback to cookie */\n  const cookieVal = useCookie(type) ? parse(getCookie(key)) : undefined\n  if (getFirst && cookieVal) {\n    return cookieVal\n  }\n\n  /* 3. Fallback to sessionStorage */\n  const sessionVal = useSession(type) ? parse(sessionStorage.getItem(key)) : undefined\n  if (getFirst && sessionVal) {\n    return sessionVal\n  }\n\n  /* 4. Fallback to window/global. */\n  const globalValue = get(key)\n\n  return getFirst ? globalValue : {\n    localStorage: localValue,\n    sessionStorage: sessionVal,\n    cookie: cookieVal,\n    global: globalValue\n  }\n}\n\n/**\n * Store values in localStorage, cookie, or window\n * @param {string} key - key of item to set\n * @param {*} value - value of item to set\n * @param {object|string} [options] - storage options. If string location of where to get storage\n * @param {string} [options.storage] - Define type of storage to pull from.\n * @returns {object} returns old value, new values, & location of storage\n */\nexport function setItem(key, value, options) {\n  if (!key || isUndefined(value)) {\n    return\n  }\n  const data = {}\n  const type = getStorageType(options)\n  const saveValue = JSON.stringify(value)\n  const setFirst = !useAll(type)\n\n  /* 1. Try localStorage */\n  if (useLocal(type)) {\n    // console.log('SET as localstorage', saveValue)\n    data[LOCAL_STORAGE] = format(LOCAL_STORAGE, value, parse(localStorage.getItem(key)))\n    // Set LocalStorage item\n    localStorage.setItem(key, saveValue)\n    if (setFirst) {\n      return data[LOCAL_STORAGE]\n    }\n  }\n\n  /* 2. Fallback to cookie */\n  if (useCookie(type)) {\n    // console.log('SET as cookie', saveValue)\n    data[COOKIE] = format(COOKIE, value, parse(getCookie(key)))\n    // Set Cookie\n    setCookie(key, saveValue)\n    if (setFirst) {\n      return data[COOKIE]\n    }\n  }\n\n  /* 3. Try sessionStorage */\n  if (useSession(type)) {\n    // console.log('SET as localstorage', saveValue)\n    data[SESSION_STORAGE] = format(SESSION_STORAGE, value, parse(sessionStorage.getItem(key)))\n    // Set sessionStorage item\n    sessionStorage.setItem(key, saveValue)\n    if (setFirst) {\n      return data[SESSION_STORAGE]\n    }\n  }\n\n  /* 4. Fallback to window/global */\n  data[GLOBAL] = format(GLOBAL, value, get(key))\n  // Set global value\n  set(key, value)\n  // Return set value(s)\n  return (setFirst) ? data[GLOBAL] : data\n}\n\n/**\n * Remove values from localStorage, cookie, or window\n * @param {string} key - key of item to set\n * @param {object|string} [options] - storage options. If string location of where to get storage\n * @param {string} [options.storage] - Define type of storage to pull from.\n */\nexport function removeItem(key, options) {\n  if (!key) return\n  const type = getStorageType(options)\n  const values = getItem(key, ALL)\n\n  const data = {}\n  /* 1. Try localStorage */\n  if (!isUndefined(values.localStorage) && useLocal(type)) {\n    localStorage.removeItem(key)\n    data[LOCAL_STORAGE] = values.localStorage\n  }\n  /* 2. Fallback to cookie */\n  if (!isUndefined(values.cookie) && useCookie(type)) {\n    removeCookie(key)\n    data[COOKIE] = values.cookie\n  }\n  /* 3. Try sessionStorage */\n  if (!isUndefined(values.sessionStorage) && useSession(type)) {\n    sessionStorage.removeItem(key)\n    data[SESSION_STORAGE] = values.sessionStorage\n  }\n  /* 4. Fallback to window/global */\n  if (!isUndefined(values.global) && useGlobal(type)) {\n    remove(key)\n    data[GLOBAL] = values.global\n  }\n  return data\n}\n\nfunction getStorageType(opts) {\n  if (!opts) return ANY\n  return isString(opts) ? opts : opts.storage\n}\n\nfunction useGlobal(storage) {\n  return useType(storage, GLOBAL)\n}\n\nfunction useLocal(storage) {\n  // If has localStorage and storage option not defined, or is set to 'localStorage' or '*'\n  return hasStorage && useType(storage, LOCAL_STORAGE)\n}\n\nfunction useCookie(storage) {\n  // If has cookies and storage option not defined, or is set to 'cookies' or '*'\n  return hasCookiesSupport && useType(storage, COOKIE)\n}\n\nfunction useSession(storage) {\n  // If has sessionStorage and storage option not defined, or is set to 'sessionStorage' or '*'\n  return hasSessionSupport && useType(storage, SESSION_STORAGE)\n}\n\nfunction useAll(storage) {\n  return storage === ALL || storage === 'all'\n}\n\nfunction useType(storage, type) {\n  return (storage === ANY || storage === type || useAll(storage))\n}\n\n/**\n * Format response\n * @param {string} location \n * @param {*} current - current value\n * @param {*} previous - previous value\n * @returns \n */\nfunction format(location, current, previous) {\n  return { location, current, previous }\n}\n\n// const TYPES = {\n//   ALL,\n//   ANY,\n//   GLOBAL,\n//   COOKIE,\n//   LOCAL_STORAGE,\n//   SESSION_STORAGE,   \n// }\n\nexport {\n  ALL,\n  ANY,\n  GLOBAL,\n  COOKIE,\n  LOCAL_STORAGE,\n  SESSION_STORAGE,\n  getCookie,\n  setCookie,\n  removeCookie,\n  globalContext,\n  hasSessionStorage,\n  hasLocalStorage,\n  hasCookies\n}\n\nexport default {\n  setItem,\n  getItem,\n  removeItem\n}", "import { Analytics } from '@analytics/core';\nexport { CONSTANTS, EVENTS } from '@analytics/core';\nimport storage from '@analytics/storage-utils';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction analyticsLib() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaultSettings = {\n    storage: storage\n  };\n  return Analytics(_objectSpread2(_objectSpread2({}, defaultSettings), opts));\n}\n\nexport { analyticsLib as Analytics, analyticsLib as default, analyticsLib as init };\n", "import d from \"./node_modules/analytics/lib/analytics.browser.es.js\";export default d;\nexport * from \"./node_modules/analytics/lib/analytics.browser.es.js\""],
  "mappings": "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",
  "names": ["obj", "key", "def", "p", "undef", "split", "length", "FUNCTION", "UNDEFINED", "FUNCTION", "OBJECT", "FUNCTION", "ANY", "ALL", "FUNCTION", "PREFIX", "FUNCTION", "PROCESS", "process", "ENV", "env", "NODE_ENV", "FUNCTION", "isBrowser", "window", "isLocalHost", "location", "hostname", "isNode", "PROCESS", "versions", "node", "isDeno", "Deno", "core", "isWebWorker", "self", "constructor", "name", "isJsDom", "navigator", "userAgent", "includes", "text", "method", "s", "charAt", "slice", "upper", "bind", "lower", "getTypeName", "val", "isNull", "ctorName", "Object", "prototype", "toString", "call", "getType", "toLowerCase", "type", "typeOf", "kind", "isFunction", "isString", "isUndefined", "isBoolean", "typeOf", "bind", "isSymbol", "isNull", "x", "isNumber", "n", "getType", "isNaN", "x", "isArray", "getType", "isObject", "obj", "isObjectLike", "proto", "Object", "getPrototypeOf", "x", "ctorName", "isFunction", "constructor", "name", "val", "isError", "x", "Error", "isString", "message", "constructor", "isNumber", "stackTraceLimit", "errorType", "ErrKind", "value", "isNull", "typeName", "getType", "isError", "Object", "getPrototypeOf", "isTypeError", "bind", "TypeError", "isSyntaxError", "SyntaxError", "obj", "isElement", "element", "type", "isEl", "Element", "HTMLDocument", "isNodeType", "nodeName", "toUpperCase", "bindArgs", "fn", "boundArgs", "isForm", "isButton", "isInput", "isSelect", "decodeUri", "s", "decodeURIComponent", "replace", "e", "getBrowserLocale", "isBrowser", "r", "navigator", "languages", "userLanguage", "length", "language", "getTimeZone", "Intl", "DateTimeFormat", "resolvedOptions", "timeZone", "error", "paramsParse", "url", "query", "temp", "params", "Object", "create", "re", "exec", "k", "decodeUri", "v", "substring", "length", "push", "prop", "arr", "split", "assign", "map", "x", "replace", "p", "match", "isBrowser", "window", "location", "search", "obj", "keyPath", "value", "lastKeyIndex", "i", "key", "uuid", "u", "i", "rb", "Math", "random", "c", "r", "toString", "GLOBAL", "KEY", "PREFIX", "globalContext", "self", "OBJECT", "global", "this", "get", "key", "set", "value", "remove", "wrap", "type", "operation", "fallback", "fn", "hasSupport", "storage", "window", "bind", "e", "cache", "UNDEFINED", "setItem", "removeItem", "err", "FUNC", "UNDEF", "ACTION_TEST", "Math", "random", "toString", "$$observable", "Symbol", "observable", "msg", "createStore", "reducer", "preloadedState", "enhancer", "undefined", "Error", "currentReducer", "currentState", "currentListeners", "nextListeners", "isDispatching", "ensureCanMutateNextListeners", "slice", "getState", "subscribe", "listener", "isSubscribed", "push", "index", "indexOf", "splice", "dispatch", "action", "isObject", "type", "listeners", "i", "length", "base", "replaceReducer", "nextReducer", "e", "outerSubscribe", "observer", "TypeError", "observeState", "next", "unsubscribe", "r", "getUndefinedStateErrorMessage", "key", "actionType", "compose", "funcs", "arg", "reduce", "a", "b", "applyMiddleware", "chain", "store", "middlewareAPI", "map", "middleware", "ANON_ID", "PREFIX", "USER_ID", "USER_TRAITS", "k", "_", "ID", "ANONID", "coreEvents", "nonEvents", "q", "acc", "curr", "registerPluginType", "name", "pluginReadyType", "utmRegex", "propRegex", "traitRegex", "initializeMiddleware", "instance", "setItem", "storage", "EVENTS", "bootstrap", "params", "user", "persistedUser", "initialUser", "isKnownId", "userId", "anonymousId", "traits", "paramsArray", "Object", "keys", "an_uid", "an_event", "groupedParams", "match", "cleanName", "replace", "campaign", "props", "raw", "setTimeout", "identify", "track", "userReducer", "state", "setItemEnd", "value", "assign", "reset", "forEach", "removeItem", "getPersistedUserData", "getItem", "tempKey", "identifyMiddleware", "t", "options", "remove", "uuid", "currentId", "currentTraits", "userIdChanged", "old", "new", "stack", "runCallback", "id", "payload", "isFunction", "waitForReady", "data", "predicate", "timeout", "Promise", "resolve", "reject", "queue", "then", "processQueue", "getPlugins", "pluginMethods", "plugins", "context", "offline", "actions", "pipeline", "item", "plugin", "loaded", "process", "processIndex", "requeue", "requeueIndex", "processAction", "currentPlugin", "currentMethod", "method", "enrichedPayload", "hasOwnProperty", "config", "pluginEvent", "called", "from", "reQueueActions", "filter", "processEvent", "allPlugins", "allMatches", "isStartEvent", "endsWithStartRegex", "abortable", "exact", "x", "pluginName", "during", "makeArgs", "abortablePlugins", "otherPlugin", "event", "abortF", "reason", "caller", "pluginsToAbort", "isArray", "includes", "JSON", "stringify", "abort", "formatPayload", "queueData", "thing", "methodName", "addToQueue", "scoped", "curScope", "namespaced", "p", "count", "curScopeData", "actionName", "text", "getNameSpacedAction", "sub", "join", "currentAct", "pname", "otherPlug", "getConfig", "val", "returnValue", "scopedPayload", "payloads", "promise", "lastLoop", "currentActionValue", "payloadValue", "shouldAbort", "abortDispatch", "funcArgs", "merged", "nameSpaceEvent", "bootstrapRegex", "readyRegex", "resolvedAction", "originalAction", "endAction", "shouldAbortAll", "abortEvent", "pluginState", "pluginData", "getPluginFunctions", "arr", "concat", "getEventNames", "eventType", "namespace", "postFix", "pluginsCount", "isString", "Array", "split", "pluginMiddleware", "systemEvents", "isReady", "updatedAction", "enablePlugin", "initializeStart", "disabled", "fromEnable", "meta", "disablePlugin", "rid", "initializeEnd", "pluginsArray", "allRegisteredPlugins", "completed", "failed", "waitForPluginsToLoad", "d", "events", "all", "calls", "ready", "E", "test", "eventsInfo", "pluginObject", "originalType", "updatedType", "activePlugins", "settings", "fromCallOptions", "isBoolean", "enabled", "info", "initialized", "allActivePluginKeys", "core", "word", "beforeFuncs", "duringFuncs", "afterFuncs", "beforeNS", "duringNS", "afterNS", "before", "after", "actionBefore", "actionDuring", "actionAfter", "hasCallback", "updated", "storageMiddleware", "DynamicMiddleware", "addMiddleware", "middlewares", "position", "_this", "removeMiddleware", "findIndex", "dynamicMiddlewares", "act", "createReducer", "newState", "getNameFromEventType", "isEnabled", "Boolean", "initialize", "togglePluginStatus", "baseName", "substring", "status", "pluginKey", "serialize", "obj", "parse", "err", "initialState", "last", "history", "trackReducer", "trackEvent", "properties", "queueReducer", "actionChain", "hashRegex", "urlPath", "url", "matches", "exec", "osName", "referrer", "locale", "timeZone", "getPageData", "pageData", "isBrowser", "n", "document", "title", "window", "location", "innerWidth", "innerHeight", "hash", "search", "canonical", "tag", "tags", "getElementsByTagName", "getAttribute", "canonicalUrl", "href", "page", "path", "width", "height", "viewData", "os", "navigator", "appVersion", "getOSNameBrowser", "getBrowserLocale", "getTimeZone", "sessionId", "app", "version", "debug", "onLine", "userAgent", "library", "timezone", "online", "excludeItems", "listen", "func", "toAdd", "fn", "ev", "watch", "cb", "bind", "Debug", "set", "origDispatch", "globalContext", "KEY", "composeWithDebug", "apply", "arguments", "ensureArray", "singleOrArray", "generateMeta", "possibleCallbacks", "resolver", "callback", "argArray", "args", "prototype", "call", "ts", "Date", "getTime", "analytics", "customReducers", "reducers", "parsedOptions", "NAMESPACE", "ERROR_URL", "definedEvents", "pluginEnabled", "methods", "c", "newArgs", "allEvents", "allEventsUnique", "Set", "get", "getUserProp", "customPlugins", "allPluginEvents", "sort", "uniqueEvents", "allSystemEvents", "nonAbortable", "paramsParse", "visitorInfo", "an_aid", "enable", "disable", "opts", "resolvedId", "identifyStart", "previousId", "eventName", "trackStart", "pageStart", "dotProp", "resetStart", "on", "startRegex", "beforeHandler", "afterHandler", "handler", "once", "detachListener", "actionData", "dispatchData", "setItemStart", "removeItemStart", "setAnonymousId", "CONSTANTS", "storeAPI", "enrichMeta", "coreReducers", "pluginsMiddleware", "composeEnhancers", "composeWithGlobalDebug", "devTools", "__REDUX_DEVTOOLS_EXTENSION_COMPOSE__", "trace", "traceLimit", "initialConfig", "current", "intialPluginState", "reducerKeys", "finalReducers", "shapeAssertionError", "finalReducerKeys", "REDUCER", "hasChanged", "nextState", "previousStateForKey", "nextStateForKey", "errorMessage", "combineReducers", "callbacks", "newEvent", "pluginKeys", "enabledPlugins", "disabledPlugins", "registerPlugins", "setInterval", "COOKIE", "isSupported", "hasCookies", "getCookie", "cookie", "setCookie", "removeCookie", "name", "remove", "tmp", "document", "indexOf", "e", "value", "ttl", "path", "domain", "secure", "window", "isSet", "arguments", "length", "set", "get", "encodeURIComponent", "Date", "toUTCString", "decodeURIComponent", "split", "LOCAL_STORAGE", "hasLocalStorage", "hasSupport", "bind", "getItem", "wrap", "get", "setItem", "set", "removeItem", "remove", "SESSION_STORAGE", "hasSessionStorage", "hasSupport", "bind", "getSessionItem", "wrap", "get", "setSessionItem", "set", "removeSessionItem", "remove", "parse", "input", "value", "JSON", "isObject", "parseFloat", "e", "hasStorage", "hasLocalStorage", "hasSessionSupport", "hasSessionStorage", "hasCookiesSupport", "hasCookies", "getItem", "key", "options", "type", "getStorageType", "getFirst", "useAll", "localValue", "useLocal", "localStorage", "isUndefined", "cookieVal", "useCookie", "getCookie", "sessionVal", "useSession", "sessionStorage", "globalValue", "get", "cookie", "global", "setItem", "data", "saveValue", "stringify", "setFirst", "LOCAL_STORAGE", "format", "COOKIE", "setCookie", "SESSION_STORAGE", "GLOBAL", "set", "removeItem", "values", "ALL", "removeCookie", "useType", "remove", "opts", "isString", "storage", "ANY", "location", "current", "previous", "J", "i", "J"]
}
